"""\nSistema de Autentica√ß√£o WebSocket para Evolution API\n\nImplementa:\n- Autentica√ß√£o de tokens JWT\n- Valida√ß√£o de API keys\n- Controle de acesso por roles\n- Rate limiting por usu√°rio\n- Auditoria de autentica√ß√£o\n\nAutor: AgnoMaster - Evolution API WebSocket Expert\nData: 2025-01-24\n"""\n\nimport asyncio\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Dict, Optional, Set, List\nfrom dataclasses import dataclass, field\nfrom collections import defaultdict\nimport hashlib\nimport secrets\n\nfrom loguru import logger\nimport redis.asyncio as redis\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom ..auth.jwt_auth import JWTAuthenticator, User, Role\nfrom ..auth.security_config import EvolutionSecuritySettings\n\n\n@dataclass\nclass WebSocketSession:\n    \"\"\"Sess√£o WebSocket autenticada\"\"\"\n    user: User\n    connection_id: str\n    authenticated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    last_activity: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    permissions: Set[str] = field(default_factory=set)\n    metadata: Dict[str, any] = field(default_factory=dict)\n    \n    def update_activity(self):\n        \"\"\"Atualiza √∫ltima atividade\"\"\"\n        self.last_activity = datetime.now(timezone.utc)\n    \n    @property\n    def session_duration(self) -> timedelta:\n        return datetime.now(timezone.utc) - self.authenticated_at\n    \n    @property\n    def idle_time(self) -> timedelta:\n        return datetime.now(timezone.utc) - self.last_activity\n    \n    def has_permission(self, permission: str) -> bool:\n        \"\"\"Verifica se tem permiss√£o\"\"\"\n        return permission in self.permissions or \"admin\" in self.permissions\n    \n    def to_dict(self) -> Dict[str, any]:\n        return {\n            \"user_id\": self.user.id,\n            \"username\": self.user.username,\n            \"connection_id\": self.connection_id,\n            \"authenticated_at\": self.authenticated_at.isoformat(),\n            \"last_activity\": self.last_activity.isoformat(),\n            \"session_duration_seconds\": self.session_duration.total_seconds(),\n            \"idle_time_seconds\": self.idle_time.total_seconds(),\n            \"permissions\": list(self.permissions),\n            \"metadata\": self.metadata\n        }\n\n\nclass WebSocketRateLimiter:\n    \"\"\"Rate limiter para WebSocket\"\"\"\n    \n    def __init__(self, redis_client: Optional[redis.Redis] = None):\n        self.redis_client = redis_client\n        self.local_buckets: Dict[str, Dict[str, any]] = defaultdict(dict)\n        self.cleanup_interval = 300  # 5 minutos\n        self._cleanup_task = None\n        \n        if not redis_client:\n            self._start_cleanup_task()\n    \n    async def is_allowed(self, user_id: str, action: str = \"message\", \n                        limit: int = 60, window: int = 60) -> bool:\n        \"\"\"Verifica se a√ß√£o √© permitida\"\"\"\n        key = f\"ws_rate_limit:{user_id}:{action}\"\n        now = datetime.now(timezone.utc)\n        \n        if self.redis_client:\n            return await self._check_redis_rate_limit(key, limit, window, now)\n        else:\n            return await self._check_local_rate_limit(key, limit, window, now)\n    \n    async def _check_redis_rate_limit(self, key: str, limit: int, window: int, now: datetime) -> bool:\n        \"\"\"Verifica rate limit usando Redis\"\"\"\n        try:\n            pipe = self.redis_client.pipeline()\n            pipe.zremrangebyscore(key, 0, now.timestamp() - window)\n            pipe.zcard(key)\n            pipe.zadd(key, {str(now.timestamp()): now.timestamp()})\n            pipe.expire(key, window)\n            \n            results = await pipe.execute()\n            current_count = results[1]\n            \n            return current_count < limit\n        except Exception as e:\n            logger.error(f\"Erro no rate limiting Redis: {e}\")\n            return True  # Permite em caso de erro\n    \n    async def _check_local_rate_limit(self, key: str, limit: int, window: int, now: datetime) -> bool:\n        \"\"\"Verifica rate limit localmente\"\"\"\n        if key not in self.local_buckets:\n            self.local_buckets[key] = {\"requests\": [], \"last_cleanup\": now}\n        \n        bucket = self.local_buckets[key]\n        cutoff_time = now - timedelta(seconds=window)\n        \n        # Remove requests antigas\n        bucket[\"requests\"] = [req_time for req_time in bucket[\"requests\"] if req_time > cutoff_time]\n        \n        # Verifica limite\n        if len(bucket[\"requests\"]) >= limit:\n            return False\n        \n        # Adiciona nova request\n        bucket[\"requests\"].append(now)\n        bucket[\"last_cleanup\"] = now\n        \n        return True\n    \n    def _start_cleanup_task(self):\n        \"\"\"Inicia task de limpeza\"\"\"\n        self._cleanup_task = asyncio.create_task(self._cleanup_loop())\n    \n    async def _cleanup_loop(self):\n        \"\"\"Loop de limpeza de buckets locais\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(self.cleanup_interval)\n                await self._cleanup_local_buckets()\n            except Exception as e:\n                logger.error(f\"Erro na limpeza de rate limit: {e}\")\n    \n    async def _cleanup_local_buckets(self):\n        \"\"\"Limpa buckets locais antigos\"\"\"\n        now = datetime.now(timezone.utc)\n        cutoff_time = now - timedelta(seconds=self.cleanup_interval)\n        \n        keys_to_remove = []\n        for key, bucket in self.local_buckets.items():\n            if bucket[\"last_cleanup\"] < cutoff_time:\n                keys_to_remove.append(key)\n        \n        for key in keys_to_remove:\n            del self.local_buckets[key]\n        \n        if keys_to_remove:\n            logger.debug(f\"Limpeza rate limit: removidos {len(keys_to_remove)} buckets\")\n\n\nclass WebSocketAuthenticator:\n    \"\"\"\n    Autenticador WebSocket\n    \"\"\"\n    \n    def __init__(self, security_settings: Optional[EvolutionSecuritySettings] = None,\n                 redis_client: Optional[redis.Redis] = None):\n        self.settings = security_settings or EvolutionSecuritySettings()\n        self.jwt_auth = JWTAuthenticator(self.settings)\n        self.redis_client = redis_client\n        self.rate_limiter = WebSocketRateLimiter(redis_client)\n        \n        # Sess√µes ativas\n        self.active_sessions: Dict[str, WebSocketSession] = {}\n        self.user_sessions: Dict[str, Set[str]] = defaultdict(set)\n        \n        # Permiss√µes por role\n        self.role_permissions = {\n            Role.ADMIN: {\n                \"admin\", \"read\", \"write\", \"delete\", \"manage_instances\",\n                \"send_messages\", \"view_logs\", \"manage_users\", \"system_control\"\n            },\n            Role.USER: {\n                \"read\", \"write\", \"manage_instances\", \"send_messages\"\n            },\n            Role.VIEWER: {\n                \"read\", \"view_logs\"\n            }\n        }\n        \n        # Auditoria\n        self.auth_attempts: List[Dict[str, any]] = []\n        self.max_auth_attempts = 1000\n        \n        logger.info(\"üîê WebSocketAuthenticator inicializado\")\n    \n    async def authenticate(self, token: str, connection_id: str) -> User:\n        \"\"\"Autentica um token e cria sess√£o\"\"\"\n        start_time = datetime.now(timezone.utc)\n        \n        try:\n            # Valida token JWT\n            user = await self.jwt_auth.verify_token(token)\n            \n            # Verifica rate limiting\n            if not await self.rate_limiter.is_allowed(user.id, \"auth\", limit=10, window=60):\n                raise ValueError(\"Rate limit de autentica√ß√£o excedido\")\n            \n            # Cria sess√£o\n            session = await self._create_session(user, connection_id)\n            \n            # Log de auditoria\n            await self._log_auth_attempt(\n                user_id=user.id,\n                username=user.username,\n                connection_id=connection_id,\n                success=True,\n                duration=(datetime.now(timezone.utc) - start_time).total_seconds()\n            )\n            \n            logger.info(f\"üîê Autentica√ß√£o WebSocket bem-sucedida: {user.username} ({connection_id})\")\n            return user\n            \n        except Exception as e:\n            # Log de auditoria para falha\n            await self._log_auth_attempt(\n                connection_id=connection_id,\n                success=False,\n                error=str(e),\n                duration=(datetime.now(timezone.utc) - start_time).total_seconds()\n            )\n            \n            logger.warning(f\"üîê Falha na autentica√ß√£o WebSocket ({connection_id}): {e}\")\n            raise\n    \n    async def authenticate_api_key(self, api_key: str, connection_id: str) -> User:\n        \"\"\"Autentica usando API key\"\"\"\n        try:\n            user = await self.jwt_auth.verify_api_key(api_key)\n            session = await self._create_session(user, connection_id)\n            \n            logger.info(f\"üîë Autentica√ß√£o API key WebSocket: {user.username} ({connection_id})\")\n            return user\n            \n        except Exception as e:\n            logger.warning(f\"üîë Falha na autentica√ß√£o API key WebSocket ({connection_id}): {e}\")\n            raise\n    \n    async def _create_session(self, user: User, connection_id: str) -> WebSocketSession:\n        \"\"\"Cria uma nova sess√£o\"\"\"\n        # Remove sess√£o existente se houver\n        if connection_id in self.active_sessions:\n            await self.remove_session(connection_id)\n        \n        # Cria nova sess√£o\n        permissions = self.role_permissions.get(user.role, set())\n        session = WebSocketSession(\n            user=user,\n            connection_id=connection_id,\n            permissions=permissions\n        )\n        \n        # Armazena sess√£o\n        self.active_sessions[connection_id] = session\n        self.user_sessions[user.id].add(connection_id)\n        \n        # Salva no Redis se dispon√≠vel\n        if self.redis_client:\n            await self._save_session_to_redis(session)\n        \n        return session\n    \n    async def remove_session(self, connection_id: str):\n        \"\"\"Remove uma sess√£o\"\"\"\n        if connection_id not in self.active_sessions:\n            return\n        \n        session = self.active_sessions[connection_id]\n        user_id = session.user.id\n        \n        # Remove das estruturas locais\n        del self.active_sessions[connection_id]\n        self.user_sessions[user_id].discard(connection_id)\n        \n        if not self.user_sessions[user_id]:\n            del self.user_sessions[user_id]\n        \n        # Remove do Redis\n        if self.redis_client:\n            await self._remove_session_from_redis(connection_id)\n        \n        logger.debug(f\"üîê Sess√£o removida: {connection_id}\")\n    \n    async def get_session(self, connection_id: str) -> Optional[WebSocketSession]:\n        \"\"\"Obt√©m uma sess√£o\"\"\"\n        session = self.active_sessions.get(connection_id)\n        \n        if session:\n            session.update_activity()\n            \n            # Atualiza no Redis\n            if self.redis_client:\n                await self._save_session_to_redis(session)\n        \n        return session\n    \n    async def verify_permission(self, connection_id: str, permission: str) -> bool:\n        \"\"\"Verifica se conex√£o tem permiss√£o\"\"\"\n        session = await self.get_session(connection_id)\n        \n        if not session:\n            return False\n        \n        return session.has_permission(permission)\n    \n    async def check_rate_limit(self, connection_id: str, action: str = \"message\",\n                              limit: int = 60, window: int = 60) -> bool:\n        \"\"\"Verifica rate limit para uma conex√£o\"\"\"\n        session = await self.get_session(connection_id)\n        \n        if not session:\n            return False\n        \n        return await self.rate_limiter.is_allowed(session.user.id, action, limit, window)\n    \n    async def get_user_sessions(self, user_id: str) -> List[WebSocketSession]:\n        \"\"\"Obt√©m todas as sess√µes de um usu√°rio\"\"\"\n        if user_id not in self.user_sessions:\n            return []\n        \n        sessions = []\n        for connection_id in self.user_sessions[user_id]:\n            session = self.active_sessions.get(connection_id)\n            if session:\n                sessions.append(session)\n        \n        return sessions\n    \n    async def revoke_user_sessions(self, user_id: str) -> int:\n        \"\"\"Revoga todas as sess√µes de um usu√°rio\"\"\"\n        if user_id not in self.user_sessions:\n            return 0\n        \n        connection_ids = list(self.user_sessions[user_id])\n        \n        for connection_id in connection_ids:\n            await self.remove_session(connection_id)\n        \n        logger.info(f\"üîê Revogadas {len(connection_ids)} sess√µes do usu√°rio {user_id}\")\n        return len(connection_ids)\n    \n    async def cleanup_expired_sessions(self, max_idle_time: int = 3600):\n        \"\"\"Limpa sess√µes expiradas\"\"\"\n        now = datetime.now(timezone.utc)\n        expired_sessions = []\n        \n        for connection_id, session in self.active_sessions.items():\n            if session.idle_time.total_seconds() > max_idle_time:\n                expired_sessions.append(connection_id)\n        \n        for connection_id in expired_sessions:\n            await self.remove_session(connection_id)\n        \n        if expired_sessions:\n            logger.info(f\"üîê Limpeza: removidas {len(expired_sessions)} sess√µes expiradas\")\n    \n    async def _save_session_to_redis(self, session: WebSocketSession):\n        \"\"\"Salva sess√£o no Redis\"\"\"\n        try:\n            key = f\"ws_session:{session.connection_id}\"\n            data = session.to_dict()\n            await self.redis_client.setex(key, 3600, json.dumps(data))\n        except Exception as e:\n            logger.error(f\"Erro ao salvar sess√£o no Redis: {e}\")\n    \n    async def _remove_session_from_redis(self, connection_id: str):\n        \"\"\"Remove sess√£o do Redis\"\"\"\n        try:\n            key = f\"ws_session:{connection_id}\"\n            await self.redis_client.delete(key)\n        except Exception as e:\n            logger.error(f\"Erro ao remover sess√£o do Redis: {e}\")\n    \n    async def _log_auth_attempt(self, connection_id: str, success: bool,\n                               user_id: Optional[str] = None, username: Optional[str] = None,\n                               error: Optional[str] = None, duration: float = 0):\n        \"\"\"Log de tentativa de autentica√ß√£o\"\"\"\n        attempt = {\n            \"timestamp\": datetime.now(timezone.utc).isoformat(),\n            \"connection_id\": connection_id,\n            \"user_id\": user_id,\n            \"username\": username,\n            \"success\": success,\n            \"error\": error,\n            \"duration_seconds\": duration\n        }\n        \n        self.auth_attempts.append(attempt)\n        \n        # Mant√©m apenas os √∫ltimos N attempts\n        if len(self.auth_attempts) > self.max_auth_attempts:\n            self.auth_attempts = self.auth_attempts[-self.max_auth_attempts:]\n        \n        # Salva no Redis se dispon√≠vel\n        if self.redis_client:\n            try:\n                key = f\"ws_auth_attempt:{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}:{connection_id}\"\n                await self.redis_client.setex(key, 86400, json.dumps(attempt))  # 24 horas\n            except Exception as e:\n                logger.error(f\"Erro ao salvar log de autentica√ß√£o: {e}\")\n    \n    def get_auth_stats(self) -> Dict[str, any]:\n        \"\"\"Retorna estat√≠sticas de autentica√ß√£o\"\"\"\n        total_attempts = len(self.auth_attempts)\n        successful_attempts = sum(1 for attempt in self.auth_attempts if attempt[\"success\"])\n        failed_attempts = total_attempts - successful_attempts\n        \n        return {\n            \"active_sessions\": len(self.active_sessions),\n            \"total_auth_attempts\": total_attempts,\n            \"successful_attempts\": successful_attempts,\n            \"failed_attempts\": failed_attempts,\n            \"success_rate\": successful_attempts / total_attempts if total_attempts > 0 else 0,\n            \"sessions_by_user\": {\n                user_id: len(connections)\n                for user_id, connections in self.user_sessions.items()\n            }\n        }\n    \n    def get_session_info(self) -> List[Dict[str, any]]:\n        \"\"\"Retorna informa√ß√µes de todas as sess√µes\"\"\"\n        return [session.to_dict() for session in self.active_sessions.values()]\n"},"query_language":"Portuguese"}}