"""\nHandlers de Eventos WebSocket para Evolution API\n\nImplementa:\n- Handlers espec√≠ficos por tipo de evento\n- Processamento ass√≠ncrono\n- Integra√ß√£o com Evolution API\n- Broadcasting inteligente\n- Monitoramento de eventos\n\nAutor: AgnoMaster - Evolution API WebSocket Expert\nData: 2025-01-24\n"""\n\nimport asyncio\nimport json\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any, Optional, List, Callable\nfrom dataclasses import dataclass\nfrom abc import ABC, abstractmethod\n\nfrom loguru import logger\nimport redis.asyncio as redis\n\nfrom .websocket_events import (\n    WebSocketEvent, EventType, EventPriority, EventCategory,\n    create_instance_event, create_message_event, create_agent_event,\n    create_system_event, create_performance_event\n)\nfrom .websocket_manager import WebSocketManager, SubscriptionType\nfrom ..evolution import EvolutionService\nfrom ..agno_service import AgnoService\nfrom ..models import WhatsAppInstance, Message\n\n\nclass EventHandler(ABC):\n    \"\"\"Handler base para eventos\"\"\"\n    \n    def __init__(self, websocket_manager: WebSocketManager):\n        self.websocket_manager = websocket_manager\n        self.logger = logger\n    \n    @abstractmethod\n    async def handle(self, event: WebSocketEvent) -> bool:\n        \"\"\"Processa o evento\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def supported_events(self) -> List[EventType]:\n        \"\"\"Tipos de eventos suportados\"\"\"\n        pass\n\n\nclass InstanceEventHandler(EventHandler):\n    \"\"\"Handler para eventos de inst√¢ncia WhatsApp\"\"\"\n    \n    def __init__(self, websocket_manager: WebSocketManager, evolution_service: EvolutionService):\n        super().__init__(websocket_manager)\n        self.evolution_service = evolution_service\n    \n    @property\n    def supported_events(self) -> List[EventType]:\n        return [\n            EventType.INSTANCE_STATUS_CHANGED,\n            EventType.INSTANCE_CREATED,\n            EventType.INSTANCE_DELETED,\n            EventType.INSTANCE_CONNECTED,\n            EventType.INSTANCE_DISCONNECTED,\n            EventType.QR_CODE_GENERATED\n        ]\n    \n    async def handle(self, event: WebSocketEvent) -> bool:\n        \"\"\"Processa eventos de inst√¢ncia\"\"\"\n        try:\n            if event.type == EventType.INSTANCE_STATUS_CHANGED:\n                return await self._handle_status_change(event)\n            elif event.type == EventType.INSTANCE_CREATED:\n                return await self._handle_instance_created(event)\n            elif event.type == EventType.INSTANCE_DELETED:\n                return await self._handle_instance_deleted(event)\n            elif event.type == EventType.INSTANCE_CONNECTED:\n                return await self._handle_instance_connected(event)\n            elif event.type == EventType.INSTANCE_DISCONNECTED:\n                return await self._handle_instance_disconnected(event)\n            elif event.type == EventType.QR_CODE_GENERATED:\n                return await self._handle_qr_code_generated(event)\n            \n            return False\n            \n        except Exception as e:\n            self.logger.error(f\"Erro no handler de inst√¢ncia: {e}\")\n            return False\n    \n    async def _handle_status_change(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata mudan√ßa de status da inst√¢ncia\"\"\"\n        instance_id = event.data.get('instance_id')\n        new_status = event.data.get('status')\n        \n        if not instance_id or not new_status:\n            return False\n        \n        # Atualiza status local\n        # TODO: Implementar atualiza√ß√£o no store local\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.INSTANCE_STATUS\n        )\n        \n        self.logger.info(f\"üì± Status da inst√¢ncia {instance_id} alterado para {new_status}\")\n        return True\n    \n    async def _handle_instance_created(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata cria√ß√£o de inst√¢ncia\"\"\"\n        instance_data = event.data\n        \n        # Broadcast para todos os usu√°rios autorizados\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.INSTANCE_STATUS\n        )\n        \n        self.logger.info(f\"üì± Nova inst√¢ncia criada: {instance_data.get('instance_name')}\")\n        return True\n    \n    async def _handle_instance_deleted(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata exclus√£o de inst√¢ncia\"\"\"\n        instance_id = event.data.get('instance_id')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.INSTANCE_STATUS\n        )\n        \n        self.logger.info(f\"üì± Inst√¢ncia deletada: {instance_id}\")\n        return True\n    \n    async def _handle_instance_connected(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata conex√£o da inst√¢ncia\"\"\"\n        instance_id = event.data.get('instance_id')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.INSTANCE_STATUS\n        )\n        \n        self.logger.info(f\"üì± Inst√¢ncia conectada: {instance_id}\")\n        return True\n    \n    async def _handle_instance_disconnected(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata desconex√£o da inst√¢ncia\"\"\"\n        instance_id = event.data.get('instance_id')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.INSTANCE_STATUS\n        )\n        \n        self.logger.warning(f\"üì± Inst√¢ncia desconectada: {instance_id}\")\n        return True\n    \n    async def _handle_qr_code_generated(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata gera√ß√£o de QR code\"\"\"\n        instance_id = event.data.get('instance_id')\n        qr_code = event.data.get('qr_code')\n        \n        if not qr_code:\n            return False\n        \n        # Broadcast apenas para usu√°rios autorizados da inst√¢ncia\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.INSTANCE_STATUS\n        )\n        \n        self.logger.info(f\"üì± QR Code gerado para inst√¢ncia: {instance_id}\")\n        return True\n\n\nclass MessageEventHandler(EventHandler):\n    \"\"\"Handler para eventos de mensagens\"\"\"\n    \n    def __init__(self, websocket_manager: WebSocketManager, evolution_service: EvolutionService):\n        super().__init__(websocket_manager)\n        self.evolution_service = evolution_service\n    \n    @property\n    def supported_events(self) -> List[EventType]:\n        return [\n            EventType.MESSAGE_RECEIVED,\n            EventType.MESSAGE_SENT,\n            EventType.MESSAGE_DELIVERED,\n            EventType.MESSAGE_READ,\n            EventType.MESSAGE_FAILED\n        ]\n    \n    async def handle(self, event: WebSocketEvent) -> bool:\n        \"\"\"Processa eventos de mensagem\"\"\"\n        try:\n            if event.type == EventType.MESSAGE_RECEIVED:\n                return await self._handle_message_received(event)\n            elif event.type == EventType.MESSAGE_SENT:\n                return await self._handle_message_sent(event)\n            elif event.type == EventType.MESSAGE_DELIVERED:\n                return await self._handle_message_delivered(event)\n            elif event.type == EventType.MESSAGE_READ:\n                return await self._handle_message_read(event)\n            elif event.type == EventType.MESSAGE_FAILED:\n                return await self._handle_message_failed(event)\n            \n            return False\n            \n        except Exception as e:\n            self.logger.error(f\"Erro no handler de mensagem: {e}\")\n            return False\n    \n    async def _handle_message_received(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata mensagem recebida\"\"\"\n        message_data = event.data\n        instance_id = message_data.get('instance_id')\n        \n        # Broadcast para subscribers de mensagens\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.MESSAGES\n        )\n        \n        self.logger.info(f\"üí¨ Mensagem recebida na inst√¢ncia {instance_id}\")\n        return True\n    \n    async def _handle_message_sent(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata mensagem enviada\"\"\"\n        message_data = event.data\n        instance_id = message_data.get('instance_id')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.MESSAGES\n        )\n        \n        self.logger.info(f\"üí¨ Mensagem enviada pela inst√¢ncia {instance_id}\")\n        return True\n    \n    async def _handle_message_delivered(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata confirma√ß√£o de entrega\"\"\"\n        message_id = event.data.get('message_id')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.MESSAGES\n        )\n        \n        self.logger.debug(f\"‚úÖ Mensagem entregue: {message_id}\")\n        return True\n    \n    async def _handle_message_read(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata confirma√ß√£o de leitura\"\"\"\n        message_id = event.data.get('message_id')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.MESSAGES\n        )\n        \n        self.logger.debug(f\"üëÅÔ∏è Mensagem lida: {message_id}\")\n        return True\n    \n    async def _handle_message_failed(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata falha no envio\"\"\"\n        message_id = event.data.get('message_id')\n        error = event.data.get('error')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.MESSAGES\n        )\n        \n        self.logger.error(f\"‚ùå Falha no envio da mensagem {message_id}: {error}\")\n        return True\n\n\nclass AgentEventHandler(EventHandler):\n    \"\"\"Handler para eventos de agentes\"\"\"\n    \n    def __init__(self, websocket_manager: WebSocketManager, agno_service: AgnoService):\n        super().__init__(websocket_manager)\n        self.agno_service = agno_service\n    \n    @property\n    def supported_events(self) -> List[EventType]:\n        return [\n            EventType.AGENT_CREATED,\n            EventType.AGENT_UPDATED,\n            EventType.AGENT_DELETED,\n            EventType.AGENT_MATERIALIZED,\n            EventType.AGENT_RESPONSE,\n            EventType.AGENT_ERROR\n        ]\n    \n    async def handle(self, event: WebSocketEvent) -> bool:\n        \"\"\"Processa eventos de agente\"\"\"\n        try:\n            if event.type == EventType.AGENT_CREATED:\n                return await self._handle_agent_created(event)\n            elif event.type == EventType.AGENT_UPDATED:\n                return await self._handle_agent_updated(event)\n            elif event.type == EventType.AGENT_DELETED:\n                return await self._handle_agent_deleted(event)\n            elif event.type == EventType.AGENT_MATERIALIZED:\n                return await self._handle_agent_materialized(event)\n            elif event.type == EventType.AGENT_RESPONSE:\n                return await self._handle_agent_response(event)\n            elif event.type == EventType.AGENT_ERROR:\n                return await self._handle_agent_error(event)\n            \n            return False\n            \n        except Exception as e:\n            self.logger.error(f\"Erro no handler de agente: {e}\")\n            return False\n    \n    async def _handle_agent_created(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata cria√ß√£o de agente\"\"\"\n        agent_data = event.data\n        \n        # Broadcast para subscribers de agentes\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.AGENT_EVENTS\n        )\n        \n        self.logger.info(f\"ü§ñ Agente criado: {agent_data.get('agent_name')}\")\n        return True\n    \n    async def _handle_agent_updated(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata atualiza√ß√£o de agente\"\"\"\n        agent_data = event.data\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.AGENT_EVENTS\n        )\n        \n        self.logger.info(f\"ü§ñ Agente atualizado: {agent_data.get('agent_name')}\")\n        return True\n    \n    async def _handle_agent_deleted(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata exclus√£o de agente\"\"\"\n        agent_data = event.data\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.AGENT_EVENTS\n        )\n        \n        self.logger.info(f\"ü§ñ Agente deletado: {agent_data.get('agent_name')}\")\n        return True\n    \n    async def _handle_agent_materialized(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata materializa√ß√£o de agente\"\"\"\n        agent_data = event.data\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.AGENT_EVENTS\n        )\n        \n        self.logger.info(f\"ü§ñ Agente materializado: {agent_data.get('agent_name')}\")\n        return True\n    \n    async def _handle_agent_response(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata resposta de agente\"\"\"\n        agent_data = event.data\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.AGENT_EVENTS\n        )\n        \n        self.logger.debug(f\"ü§ñ Resposta do agente: {agent_data.get('agent_name')}\")\n        return True\n    \n    async def _handle_agent_error(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata erro de agente\"\"\"\n        agent_data = event.data\n        error = agent_data.get('error')\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.AGENT_EVENTS\n        )\n        \n        self.logger.error(f\"ü§ñ Erro no agente {agent_data.get('agent_name')}: {error}\")\n        return True\n\n\nclass SystemEventHandler(EventHandler):\n    \"\"\"Handler para eventos do sistema\"\"\"\n    \n    @property\n    def supported_events(self) -> List[EventType]:\n        return [\n            EventType.SYSTEM_STATUS,\n            EventType.SYSTEM_ERROR,\n            EventType.SYSTEM_MAINTENANCE,\n            EventType.RATE_LIMIT_EXCEEDED,\n            EventType.PERFORMANCE_METRICS,\n            EventType.HEALTH_CHECK\n        ]\n    \n    async def handle(self, event: WebSocketEvent) -> bool:\n        \"\"\"Processa eventos do sistema\"\"\"\n        try:\n            if event.type == EventType.SYSTEM_STATUS:\n                return await self._handle_system_status(event)\n            elif event.type == EventType.SYSTEM_ERROR:\n                return await self._handle_system_error(event)\n            elif event.type == EventType.SYSTEM_MAINTENANCE:\n                return await self._handle_system_maintenance(event)\n            elif event.type == EventType.RATE_LIMIT_EXCEEDED:\n                return await self._handle_rate_limit_exceeded(event)\n            elif event.type == EventType.PERFORMANCE_METRICS:\n                return await self._handle_performance_metrics(event)\n            elif event.type == EventType.HEALTH_CHECK:\n                return await self._handle_health_check(event)\n            \n            return False\n            \n        except Exception as e:\n            self.logger.error(f\"Erro no handler do sistema: {e}\")\n            return False\n    \n    async def _handle_system_status(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata status do sistema\"\"\"\n        # Broadcast para subscribers do sistema\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.SYSTEM_EVENTS\n        )\n        \n        self.logger.info(f\"‚öôÔ∏è Status do sistema: {event.data.get('status')}\")\n        return True\n    \n    async def _handle_system_error(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata erro do sistema\"\"\"\n        error_data = event.data\n        \n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.SYSTEM_EVENTS\n        )\n        \n        self.logger.error(f\"‚öôÔ∏è Erro do sistema: {error_data.get('message')}\")\n        return True\n    \n    async def _handle_system_maintenance(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata manuten√ß√£o do sistema\"\"\"\n        # Broadcast para todos os usu√°rios\n        await self.websocket_manager.broadcast_event(event)\n        \n        self.logger.warning(f\"‚öôÔ∏è Manuten√ß√£o do sistema: {event.data.get('message')}\")\n        return True\n    \n    async def _handle_rate_limit_exceeded(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata excesso de rate limit\"\"\"\n        user_id = event.data.get('user_id')\n        \n        # Envia apenas para o usu√°rio espec√≠fico\n        if user_id:\n            await self.websocket_manager.send_to_user(user_id, event)\n        \n        self.logger.warning(f\"‚ö†Ô∏è Rate limit excedido para usu√°rio: {user_id}\")\n        return True\n    \n    async def _handle_performance_metrics(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata m√©tricas de performance\"\"\"\n        # Broadcast apenas para admins\n        # TODO: Implementar filtro por role\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.SYSTEM_EVENTS\n        )\n        \n        self.logger.debug(\"üìä M√©tricas de performance enviadas\")\n        return True\n    \n    async def _handle_health_check(self, event: WebSocketEvent) -> bool:\n        \"\"\"Trata health check\"\"\"\n        # Broadcast para subscribers\n        await self.websocket_manager.broadcast_event(\n            event, SubscriptionType.SYSTEM_EVENTS\n        )\n        \n        self.logger.debug(\"‚ù§Ô∏è Health check enviado\")\n        return True\n\n\nclass WebSocketHandlers:\n    \"\"\"\n    Gerenciador de handlers WebSocket\n    \"\"\"\n    \n    def __init__(self, websocket_manager: WebSocketManager, \n                 evolution_service: Optional[EvolutionService] = None,\n                 agno_service: Optional[AgnoService] = None):\n        self.websocket_manager = websocket_manager\n        self.handlers: Dict[EventType, EventHandler] = {}\n        \n        # Inicializa handlers\n        self._setup_handlers(evolution_service, agno_service)\n        \n        # Estat√≠sticas\n        self.events_processed = 0\n        self.events_failed = 0\n        self.start_time = datetime.now(timezone.utc)\n        \n        logger.info(\"üéØ WebSocketHandlers inicializado\")\n    \n    def _setup_handlers(self, evolution_service: Optional[EvolutionService],\n                       agno_service: Optional[AgnoService]):\n        \"\"\"Configura handlers\"\"\"\n        # Handler de inst√¢ncias\n        if evolution_service:\n            instance_handler = InstanceEventHandler(self.websocket_manager, evolution_service)\n            for event_type in instance_handler.supported_events:\n                self.handlers[event_type] = instance_handler\n            \n            # Handler de mensagens\n            message_handler = MessageEventHandler(self.websocket_manager, evolution_service)\n            for event_type in message_handler.supported_events:\n                self.handlers[event_type] = message_handler\n        \n        # Handler de agentes\n        if agno_service:\n            agent_handler = AgentEventHandler(self.websocket_manager, agno_service)\n            for event_type in agent_handler.supported_events:\n                self.handlers[event_type] = agent_handler\n        \n        # Handler do sistema\n        system_handler = SystemEventHandler(self.websocket_manager)\n        for event_type in system_handler.supported_events:\n            self.handlers[event_type] = system_handler\n    \n    async def process_event(self, event: WebSocketEvent) -> bool:\n        \"\"\"Processa um evento\"\"\"\n        start_time = datetime.now(timezone.utc)\n        \n        try:\n            handler = self.handlers.get(event.type)\n            \n            if not handler:\n                logger.warning(f\"Handler n√£o encontrado para evento: {event.type}\")\n                return False\n            \n            # Processa evento\n            success = await handler.handle(event)\n            \n            # Atualiza estat√≠sticas\n            if success:\n                self.events_processed += 1\n            else:\n                self.events_failed += 1\n            \n            # Log de performance\n            duration = (datetime.now(timezone.utc) - start_time).total_seconds()\n            if duration > 1.0:  # Log se demorar mais de 1 segundo\n                logger.warning(f\"Evento {event.type} demorou {duration:.2f}s para processar\")\n            \n            return success\n            \n        except Exception as e:\n            self.events_failed += 1\n            logger.error(f\"Erro ao processar evento {event.type}: {e}\")\n            return False\n    \n    def add_handler(self, event_type: EventType, handler: EventHandler):\n        \"\"\"Adiciona um handler customizado\"\"\"\n        self.handlers[event_type] = handler\n        logger.info(f\"Handler adicionado para evento: {event_type}\")\n    \n    def remove_handler(self, event_type: EventType):\n        \"\"\"Remove um handler\"\"\"\n        if event_type in self.handlers:\n            del self.handlers[event_type]\n            logger.info(f\"Handler removido para evento: {event_type}\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Retorna estat√≠sticas dos handlers\"\"\"\n        uptime = (datetime.now(timezone.utc) - self.start_time).total_seconds()\n        \n        return {\n            \"events_processed\": self.events_processed,\n            \"events_failed\": self.events_failed,\n            \"success_rate\": self.events_processed / (self.events_processed + self.events_failed) if (self.events_processed + self.events_failed) > 0 else 0,\n            \"events_per_second\": self.events_processed / uptime if uptime > 0 else 0,\n            \"uptime_seconds\": uptime,\n            \"registered_handlers\": len(self.handlers),\n            \"handler_types\": list(self.handlers.keys())\n        }\n    \n    def list_handlers(self) -> Dict[str, str]:\n        \"\"\"Lista handlers registrados\"\"\"\n        return {\n            event_type.value: handler.__class__.__name__\n            for event_type, handler in self.handlers.items()\n        }\n\n\n# Fun√ß√µes utilit√°rias para criar eventos comuns\nasync def emit_instance_status_change(websocket_manager: WebSocketManager,\n                                     instance_id: str, instance_name: str,\n                                     old_status: str, new_status: str):\n    \"\"\"Emite evento de mudan√ßa de status da inst√¢ncia\"\"\"\n    event = create_instance_event(\n        EventType.INSTANCE_STATUS_CHANGED,\n        instance_id=instance_id,\n        instance_name=instance_name,\n        status=new_status,\n        metadata={\"old_status\": old_status}\n    )\n    \n    await websocket_manager.broadcast_event(event, SubscriptionType.INSTANCE_STATUS)\n\n\nasync def emit_message_received(websocket_manager: WebSocketManager,\n                              message_id: str, instance_id: str,\n                              from_number: str, content: str):\n    \"\"\"Emite evento de mensagem recebida\"\"\"\n    event = create_message_event(\n        EventType.MESSAGE_RECEIVED,\n        message_id=message_id,\n        instance_id=instance_id,\n        from_number=from_number,\n        content=content\n    )\n    \n    await websocket_manager.broadcast_event(event, SubscriptionType.MESSAGES)\n\n\nasync def emit_agent_response(websocket_manager: WebSocketManager,\n                            agent_id: str, agent_name: str,\n                            response: str, execution_time: float):\n    \"\"\"Emite evento de resposta do agente\"\"\"\n    event = create_agent_event(\n        EventType.AGENT_RESPONSE,\n        agent_id=agent_id,\n        agent_name=agent_name,\n        action=\"response\",\n        status=\"completed\",\n        response=response,\n        execution_time=execution_time\n    )\n    \n    await websocket_manager.broadcast_event(event, SubscriptionType.AGENT_EVENTS)\n\n\nasync def emit_system_error(websocket_manager: WebSocketManager,\n                          component: str, error_message: str,\n                          error_details: Optional[Dict[str, Any]] = None):\n    \"\"\"Emite evento de erro do sistema\"\"\"\n    event = create_system_event(\n        EventType.SYSTEM_ERROR,\n        component=component,\n        status=\"error\",\n        message=error_message,\n        error=error_message,\n        metrics=error_details or {}\n    )\n    \n    await websocket_manager.broadcast_event(event, SubscriptionType.SYSTEM_EVENTS)\n\n\nasync def emit_performance_metrics(websocket_manager: WebSocketManager,\n                                  cpu_usage: float, memory_usage: float,\n                                  active_connections: int, requests_per_second: float,\n                                  response_time_avg: float, error_rate: float):\n    \"\"\"Emite m√©tricas de performance\"\"\"\n    event = create_performance_event(\n        cpu_usage=cpu_usage,\n        memory_usage=memory_usage,\n        active_connections=active_connections,\n        requests_per_second=requests_per_second,\n        response_time_avg=response_time_avg,\n        error_rate=error_rate\n    )\n    \n    await websocket_manager.broadcast_event(event, SubscriptionType.SYSTEM_EVENTS)\n"},"query_language":"Portuguese"}}