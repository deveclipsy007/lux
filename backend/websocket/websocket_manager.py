"""\nGerenciador de WebSockets para Evolution API\n\nImplementa:\n- Gerenciamento de conex√µes\n- Broadcasting de eventos\n- Autentica√ß√£o de WebSocket\n- Rate limiting\n- Reconex√£o autom√°tica\n- Monitoramento de sa√∫de\n\nAutor: AgnoMaster - Evolution API WebSocket Expert\nData: 2025-01-24\n"""\n\nimport json\nimport asyncio\nimport time\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Dict, List, Set, Optional, Any, Callable\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom collections import defaultdict\nimport uuid\n\nfrom fastapi import WebSocket, WebSocketDisconnect, status\nfrom loguru import logger\nimport redis.asyncio as redis\n\nfrom .websocket_events import EventType, WebSocketEvent\nfrom .websocket_auth import WebSocketAuthenticator\nfrom ..auth.jwt_auth import User\n\n\nclass ConnectionState(str, Enum):\n    \"\"\"Estados de conex√£o WebSocket\"\"\"\n    CONNECTING = \"connecting\"\n    CONNECTED = \"connected\"\n    AUTHENTICATED = \"authenticated\"\n    DISCONNECTING = \"disconnecting\"\n    DISCONNECTED = \"disconnected\"\n    ERROR = \"error\"\n\n\nclass SubscriptionType(str, Enum):\n    \"\"\"Tipos de subscri√ß√£o\"\"\"\n    ALL = \"all\"\n    INSTANCE_STATUS = \"instance_status\"\n    MESSAGES = \"messages\"\n    AGENT_EVENTS = \"agent_events\"\n    SYSTEM_EVENTS = \"system_events\"\n    USER_EVENTS = \"user_events\"\n\n\n@dataclass\nclass WebSocketConnection:\n    \"\"\"Representa uma conex√£o WebSocket\"\"\"\n    id: str\n    websocket: WebSocket\n    user: Optional[User] = None\n    state: ConnectionState = ConnectionState.CONNECTING\n    connected_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    last_ping: Optional[datetime] = None\n    last_pong: Optional[datetime] = None\n    subscriptions: Set[SubscriptionType] = field(default_factory=set)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    message_count: int = 0\n    error_count: int = 0\n    \n    @property\n    def is_authenticated(self) -> bool:\n        return self.state == ConnectionState.AUTHENTICATED and self.user is not None\n    \n    @property\n    def is_alive(self) -> bool:\n        return self.state in [ConnectionState.CONNECTED, ConnectionState.AUTHENTICATED]\n    \n    @property\n    def connection_duration(self) -> timedelta:\n        return datetime.now(timezone.utc) - self.connected_at\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"user_id\": self.user.id if self.user else None,\n            \"username\": self.user.username if self.user else None,\n            \"state\": self.state.value,\n            \"connected_at\": self.connected_at.isoformat(),\n            \"last_ping\": self.last_ping.isoformat() if self.last_ping else None,\n            \"last_pong\": self.last_pong.isoformat() if self.last_pong else None,\n            \"subscriptions\": list(self.subscriptions),\n            \"message_count\": self.message_count,\n            \"error_count\": self.error_count,\n            \"connection_duration_seconds\": self.connection_duration.total_seconds(),\n            \"metadata\": self.metadata\n        }\n\n\nclass ConnectionManager:\n    \"\"\"\n    Gerenciador de conex√µes WebSocket\n    \"\"\"\n    \n    def __init__(self, redis_client: Optional[redis.Redis] = None):\n        self.connections: Dict[str, WebSocketConnection] = {}\n        self.user_connections: Dict[str, Set[str]] = defaultdict(set)\n        self.subscription_connections: Dict[SubscriptionType, Set[str]] = defaultdict(set)\n        self.redis_client = redis_client\n        \n        # Estat√≠sticas\n        self.total_connections = 0\n        self.total_messages = 0\n        self.start_time = datetime.now(timezone.utc)\n        \n        # Tasks\n        self._heartbeat_task = None\n        self._cleanup_task = None\n        self._stats_task = None\n        \n        self._start_background_tasks()\n        \n        logger.info(\"üîå ConnectionManager inicializado\")\n    \n    async def connect(self, websocket: WebSocket, connection_id: Optional[str] = None) -> WebSocketConnection:\n        \"\"\"Aceita uma nova conex√£o WebSocket\"\"\"\n        await websocket.accept()\n        \n        if not connection_id:\n            connection_id = str(uuid.uuid4())\n        \n        connection = WebSocketConnection(\n            id=connection_id,\n            websocket=websocket,\n            state=ConnectionState.CONNECTED\n        )\n        \n        self.connections[connection_id] = connection\n        self.total_connections += 1\n        \n        logger.info(f\"üîå Nova conex√£o WebSocket: {connection_id}\")\n        \n        # Envia mensagem de boas-vindas\n        await self.send_to_connection(connection_id, WebSocketEvent(\n            type=EventType.CONNECTION_ESTABLISHED,\n            data={\n                \"connection_id\": connection_id,\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                \"message\": \"Conex√£o estabelecida com sucesso\"\n            }\n        ))\n        \n        return connection\n    \n    async def disconnect(self, connection_id: str, code: int = 1000, reason: str = \"Normal closure\"):\n        \"\"\"Desconecta uma conex√£o WebSocket\"\"\"\n        if connection_id not in self.connections:\n            return\n        \n        connection = self.connections[connection_id]\n        connection.state = ConnectionState.DISCONNECTING\n        \n        try:\n            await connection.websocket.close(code=code, reason=reason)\n        except Exception as e:\n            logger.warning(f\"Erro ao fechar WebSocket {connection_id}: {e}\")\n        \n        # Remove das estruturas de dados\n        if connection.user:\n            self.user_connections[connection.user.id].discard(connection_id)\n            if not self.user_connections[connection.user.id]:\n                del self.user_connections[connection.user.id]\n        \n        for subscription in connection.subscriptions:\n            self.subscription_connections[subscription].discard(connection_id)\n        \n        connection.state = ConnectionState.DISCONNECTED\n        del self.connections[connection_id]\n        \n        logger.info(f\"üîå Conex√£o WebSocket desconectada: {connection_id} ({reason})\")\n    \n    async def authenticate_connection(self, connection_id: str, user: User):\n        \"\"\"Autentica uma conex√£o\"\"\"\n        if connection_id not in self.connections:\n            raise ValueError(f\"Conex√£o {connection_id} n√£o encontrada\")\n        \n        connection = self.connections[connection_id]\n        connection.user = user\n        connection.state = ConnectionState.AUTHENTICATED\n        \n        # Adiciona √† lista de conex√µes do usu√°rio\n        self.user_connections[user.id].add(connection_id)\n        \n        logger.info(f\"üîê Conex√£o autenticada: {connection_id} (usu√°rio: {user.username})\")\n        \n        # Envia confirma√ß√£o de autentica√ß√£o\n        await self.send_to_connection(connection_id, WebSocketEvent(\n            type=EventType.AUTHENTICATION_SUCCESS,\n            data={\n                \"user_id\": user.id,\n                \"username\": user.username,\n                \"timestamp\": datetime.now(timezone.utc).isoformat()\n            }\n        ))\n    \n    async def subscribe(self, connection_id: str, subscription_type: SubscriptionType):\n        \"\"\"Adiciona uma subscri√ß√£o\"\"\"\n        if connection_id not in self.connections:\n            raise ValueError(f\"Conex√£o {connection_id} n√£o encontrada\")\n        \n        connection = self.connections[connection_id]\n        connection.subscriptions.add(subscription_type)\n        self.subscription_connections[subscription_type].add(connection_id)\n        \n        logger.debug(f\"üì° Subscri√ß√£o adicionada: {connection_id} -> {subscription_type.value}\")\n        \n        # Confirma subscri√ß√£o\n        await self.send_to_connection(connection_id, WebSocketEvent(\n            type=EventType.SUBSCRIPTION_CONFIRMED,\n            data={\n                \"subscription_type\": subscription_type.value,\n                \"timestamp\": datetime.now(timezone.utc).isoformat()\n            }\n        ))\n    \n    async def unsubscribe(self, connection_id: str, subscription_type: SubscriptionType):\n        \"\"\"Remove uma subscri√ß√£o\"\"\"\n        if connection_id not in self.connections:\n            return\n        \n        connection = self.connections[connection_id]\n        connection.subscriptions.discard(subscription_type)\n        self.subscription_connections[subscription_type].discard(connection_id)\n        \n        logger.debug(f\"üì° Subscri√ß√£o removida: {connection_id} -> {subscription_type.value}\")\n    \n    async def send_to_connection(self, connection_id: str, event: WebSocketEvent) -> bool:\n        \"\"\"Envia um evento para uma conex√£o espec√≠fica\"\"\"\n        if connection_id not in self.connections:\n            return False\n        \n        connection = self.connections[connection_id]\n        \n        if not connection.is_alive:\n            return False\n        \n        try:\n            message = json.dumps(event.to_dict())\n            await connection.websocket.send_text(message)\n            connection.message_count += 1\n            self.total_messages += 1\n            return True\n        except Exception as e:\n            logger.error(f\"Erro ao enviar mensagem para {connection_id}: {e}\")\n            connection.error_count += 1\n            await self.disconnect(connection_id, code=1011, reason=\"Send error\")\n            return False\n    \n    async def send_to_user(self, user_id: str, event: WebSocketEvent) -> int:\n        \"\"\"Envia um evento para todas as conex√µes de um usu√°rio\"\"\"\n        if user_id not in self.user_connections:\n            return 0\n        \n        sent_count = 0\n        connection_ids = list(self.user_connections[user_id])\n        \n        for connection_id in connection_ids:\n            if await self.send_to_connection(connection_id, event):\n                sent_count += 1\n        \n        return sent_count\n    \n    async def broadcast_to_subscription(self, subscription_type: SubscriptionType, event: WebSocketEvent) -> int:\n        \"\"\"Faz broadcast para todas as conex√µes de uma subscri√ß√£o\"\"\"\n        if subscription_type not in self.subscription_connections:\n            return 0\n        \n        sent_count = 0\n        connection_ids = list(self.subscription_connections[subscription_type])\n        \n        for connection_id in connection_ids:\n            if await self.send_to_connection(connection_id, event):\n                sent_count += 1\n        \n        return sent_count\n    \n    async def broadcast_to_all(self, event: WebSocketEvent) -> int:\n        \"\"\"Faz broadcast para todas as conex√µes\"\"\"\n        sent_count = 0\n        connection_ids = list(self.connections.keys())\n        \n        for connection_id in connection_ids:\n            if await self.send_to_connection(connection_id, event):\n                sent_count += 1\n        \n        return sent_count\n    \n    async def handle_ping(self, connection_id: str):\n        \"\"\"Trata ping de uma conex√£o\"\"\"\n        if connection_id not in self.connections:\n            return\n        \n        connection = self.connections[connection_id]\n        connection.last_ping = datetime.now(timezone.utc)\n        \n        # Responde com pong\n        await self.send_to_connection(connection_id, WebSocketEvent(\n            type=EventType.PONG,\n            data={\"timestamp\": connection.last_ping.isoformat()}\n        ))\n    \n    async def handle_pong(self, connection_id: str):\n        \"\"\"Trata pong de uma conex√£o\"\"\"\n        if connection_id not in self.connections:\n            return\n        \n        connection = self.connections[connection_id]\n        connection.last_pong = datetime.now(timezone.utc)\n    \n    def get_connection_stats(self) -> Dict[str, Any]:\n        \"\"\"Retorna estat√≠sticas das conex√µes\"\"\"\n        active_connections = len(self.connections)\n        authenticated_connections = sum(1 for conn in self.connections.values() if conn.is_authenticated)\n        \n        return {\n            \"active_connections\": active_connections,\n            \"authenticated_connections\": authenticated_connections,\n            \"total_connections\": self.total_connections,\n            \"total_messages\": self.total_messages,\n            \"uptime_seconds\": (datetime.now(timezone.utc) - self.start_time).total_seconds(),\n            \"connections_by_subscription\": {\n                sub_type.value: len(connections)\n                for sub_type, connections in self.subscription_connections.items()\n            },\n            \"connections_by_user\": {\n                user_id: len(connections)\n                for user_id, connections in self.user_connections.items()\n            }\n        }\n    \n    def get_connection_info(self, connection_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Retorna informa√ß√µes de uma conex√£o\"\"\"\n        if connection_id not in self.connections:\n            return None\n        \n        return self.connections[connection_id].to_dict()\n    \n    def list_connections(self) -> List[Dict[str, Any]]:\n        \"\"\"Lista todas as conex√µes\"\"\"\n        return [conn.to_dict() for conn in self.connections.values()]\n    \n    def _start_background_tasks(self):\n        \"\"\"Inicia tasks em background\"\"\"\n        self._heartbeat_task = asyncio.create_task(self._heartbeat_loop())\n        self._cleanup_task = asyncio.create_task(self._cleanup_loop())\n        self._stats_task = asyncio.create_task(self._stats_loop())\n    \n    async def _heartbeat_loop(self):\n        \"\"\"Loop de heartbeat para verificar conex√µes\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(30)  # Heartbeat a cada 30 segundos\n                await self._send_heartbeat()\n            except Exception as e:\n                logger.error(f\"Erro no heartbeat: {e}\")\n    \n    async def _send_heartbeat(self):\n        \"\"\"Envia heartbeat para todas as conex√µes\"\"\"\n        now = datetime.now(timezone.utc)\n        stale_connections = []\n        \n        for connection_id, connection in self.connections.items():\n            # Verifica se a conex√£o est√° \"morta\"\n            if connection.last_pong:\n                time_since_pong = now - connection.last_pong\n                if time_since_pong > timedelta(minutes=2):\n                    stale_connections.append(connection_id)\n                    continue\n            \n            # Envia ping\n            await self.send_to_connection(connection_id, WebSocketEvent(\n                type=EventType.PING,\n                data={\"timestamp\": now.isoformat()}\n            ))\n        \n        # Remove conex√µes \"mortas\"\n        for connection_id in stale_connections:\n            logger.warning(f\"Removendo conex√£o inativa: {connection_id}\")\n            await self.disconnect(connection_id, code=1001, reason=\"Connection timeout\")\n    \n    async def _cleanup_loop(self):\n        \"\"\"Loop de limpeza\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(300)  # Limpeza a cada 5 minutos\n                await self._cleanup_connections()\n            except Exception as e:\n                logger.error(f\"Erro na limpeza: {e}\")\n    \n    async def _cleanup_connections(self):\n        \"\"\"Limpa conex√µes √≥rf√£s\"\"\"\n        orphaned_connections = []\n        \n        for connection_id, connection in self.connections.items():\n            try:\n                # Tenta enviar uma mensagem de teste\n                await connection.websocket.ping()\n            except Exception:\n                orphaned_connections.append(connection_id)\n        \n        for connection_id in orphaned_connections:\n            logger.warning(f\"Removendo conex√£o √≥rf√£: {connection_id}\")\n            await self.disconnect(connection_id, code=1011, reason=\"Connection lost\")\n    \n    async def _stats_loop(self):\n        \"\"\"Loop de estat√≠sticas\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(60)  # Estat√≠sticas a cada minuto\n                stats = self.get_connection_stats()\n                logger.info(f\"üìä WebSocket Stats: {stats['active_connections']} ativas, {stats['total_messages']} mensagens\")\n                \n                # Salva no Redis se dispon√≠vel\n                if self.redis_client:\n                    await self.redis_client.setex(\n                        \"websocket_stats\",\n                        300,  # 5 minutos\n                        json.dumps(stats)\n                    )\n            except Exception as e:\n                logger.error(f\"Erro nas estat√≠sticas: {e}\")\n\n\nclass WebSocketManager:\n    \"\"\"\n    Gerenciador principal de WebSockets\n    \"\"\"\n    \n    def __init__(self, redis_client: Optional[redis.Redis] = None):\n        self.connection_manager = ConnectionManager(redis_client)\n        self.authenticator = WebSocketAuthenticator()\n        self.redis_client = redis_client\n        \n        # Event handlers\n        self.event_handlers: Dict[EventType, List[Callable]] = defaultdict(list)\n        \n        logger.info(\"üöÄ WebSocketManager inicializado\")\n    \n    async def handle_websocket(self, websocket: WebSocket, connection_id: Optional[str] = None):\n        \"\"\"Trata uma nova conex√£o WebSocket\"\"\"\n        connection = await self.connection_manager.connect(websocket, connection_id)\n        \n        try:\n            while True:\n                # Recebe mensagem\n                data = await websocket.receive_text()\n                await self._handle_message(connection.id, data)\n        \n        except WebSocketDisconnect:\n            logger.info(f\"Cliente desconectado: {connection.id}\")\n        except Exception as e:\n            logger.error(f\"Erro na conex√£o WebSocket {connection.id}: {e}\")\n        finally:\n            await self.connection_manager.disconnect(connection.id)\n    \n    async def _handle_message(self, connection_id: str, message: str):\n        \"\"\"Trata uma mensagem recebida\"\"\"\n        try:\n            data = json.loads(message)\n            event_type = EventType(data.get('type'))\n            event_data = data.get('data', {})\n            \n            # Cria evento\n            event = WebSocketEvent(\n                type=event_type,\n                data=event_data,\n                connection_id=connection_id\n            )\n            \n            # Trata evento\n            await self._process_event(event)\n            \n        except json.JSONDecodeError:\n            logger.warning(f\"Mensagem JSON inv√°lida de {connection_id}: {message}\")\n        except ValueError as e:\n            logger.warning(f\"Tipo de evento inv√°lido de {connection_id}: {e}\")\n        except Exception as e:\n            logger.error(f\"Erro ao processar mensagem de {connection_id}: {e}\")\n    \n    async def _process_event(self, event: WebSocketEvent):\n        \"\"\"Processa um evento\"\"\"\n        # Eventos do sistema\n        if event.type == EventType.AUTHENTICATE:\n            await self._handle_authenticate(event)\n        elif event.type == EventType.SUBSCRIBE:\n            await self._handle_subscribe(event)\n        elif event.type == EventType.UNSUBSCRIBE:\n            await self._handle_unsubscribe(event)\n        elif event.type == EventType.PING:\n            await self.connection_manager.handle_ping(event.connection_id)\n        elif event.type == EventType.PONG:\n            await self.connection_manager.handle_pong(event.connection_id)\n        \n        # Chama handlers customizados\n        for handler in self.event_handlers.get(event.type, []):\n            try:\n                await handler(event)\n            except Exception as e:\n                logger.error(f\"Erro no handler de evento {event.type}: {e}\")\n    \n    async def _handle_authenticate(self, event: WebSocketEvent):\n        \"\"\"Trata autentica√ß√£o\"\"\"\n        token = event.data.get('token')\n        if not token:\n            await self.connection_manager.send_to_connection(\n                event.connection_id,\n                WebSocketEvent(\n                    type=EventType.AUTHENTICATION_FAILED,\n                    data={\"error\": \"Token n√£o fornecido\"}\n                )\n            )\n            return\n        \n        try:\n            user = await self.authenticator.authenticate(token)\n            await self.connection_manager.authenticate_connection(event.connection_id, user)\n        except Exception as e:\n            await self.connection_manager.send_to_connection(\n                event.connection_id,\n                WebSocketEvent(\n                    type=EventType.AUTHENTICATION_FAILED,\n                    data={\"error\": str(e)}\n                )\n            )\n    \n    async def _handle_subscribe(self, event: WebSocketEvent):\n        \"\"\"Trata subscri√ß√£o\"\"\"\n        subscription_type = event.data.get('subscription_type')\n        if not subscription_type:\n            return\n        \n        try:\n            sub_type = SubscriptionType(subscription_type)\n            await self.connection_manager.subscribe(event.connection_id, sub_type)\n        except ValueError:\n            logger.warning(f\"Tipo de subscri√ß√£o inv√°lido: {subscription_type}\")\n    \n    async def _handle_unsubscribe(self, event: WebSocketEvent):\n        \"\"\"Trata cancelamento de subscri√ß√£o\"\"\"\n        subscription_type = event.data.get('subscription_type')\n        if not subscription_type:\n            return\n        \n        try:\n            sub_type = SubscriptionType(subscription_type)\n            await self.connection_manager.unsubscribe(event.connection_id, sub_type)\n        except ValueError:\n            logger.warning(f\"Tipo de subscri√ß√£o inv√°lido: {subscription_type}\")\n    \n    def add_event_handler(self, event_type: EventType, handler: Callable):\n        \"\"\"Adiciona um handler de evento\"\"\"\n        self.event_handlers[event_type].append(handler)\n    \n    def remove_event_handler(self, event_type: EventType, handler: Callable):\n        \"\"\"Remove um handler de evento\"\"\"\n        if handler in self.event_handlers[event_type]:\n            self.event_handlers[event_type].remove(handler)\n    \n    async def broadcast_event(self, event: WebSocketEvent, subscription_type: Optional[SubscriptionType] = None):\n        \"\"\"Faz broadcast de um evento\"\"\"\n        if subscription_type:\n            return await self.connection_manager.broadcast_to_subscription(subscription_type, event)\n        else:\n            return await self.connection_manager.broadcast_to_all(event)\n    \n    async def send_to_user(self, user_id: str, event: WebSocketEvent):\n        \"\"\"Envia evento para um usu√°rio espec√≠fico\"\"\"\n        return await self.connection_manager.send_to_user(user_id, event)\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Retorna estat√≠sticas\"\"\"\n        return self.connection_manager.get_connection_stats()\n    \n    def get_connections(self) -> List[Dict[str, Any]]:\n        \"\"\"Lista conex√µes\"\"\"\n        return self.connection_manager.list_connections()\n"}},"query_language":"Portuguese"}}