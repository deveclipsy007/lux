"""\nTutoriais da Evolution API\n\nImplementa:\n- Guias passo a passo\n- Tutoriais interativos\n- Casos de uso práticos\n- Fluxos completos\n- Troubleshooting\n\nAutor: AgnoMaster - Evolution API Tutorial Expert\nData: 2025-01-24\n"""\n\nfrom typing import Dict, Any, List\nfrom datetime import datetime\nimport json\n\n\nclass EvolutionTutorials:\n    \"\"\"\n    Tutoriais completos da Evolution API\n    \"\"\"\n    \n    @staticmethod\n    def get_quick_start_tutorial() -> Dict[str, Any]:\n        \"\"\"Tutorial de início rápido\"\"\"\n        return {\n            \"title\": \"Início Rápido - Evolution API\",\n            \"description\": \"Configure e use a Evolution API em 10 minutos\",\n            \"duration\": \"10 minutos\",\n            \"difficulty\": \"Iniciante\",\n            \"steps\": [\n                {\n                    \"step\": 1,\n                    \"title\": \"Configuração Inicial\",\n                    \"description\": \"Configure o ambiente e dependências\",\n                    \"code\": \"\"\"\n# 1. Clone o repositório\ngit clone https://github.com/evolution-api/evolution-api.git\ncd evolution-api\n\n# 2. Instale as dependências\npip install -r requirements.txt\n\n# 3. Configure as variáveis de ambiente\ncp .env.example .env\n\n# 4. Edite o arquivo .env\nJWT_SECRET=seu_jwt_secret_aqui\nAPI_KEY_SECRET=sua_api_key_secret_aqui\nDATABASE_URL=postgresql://user:pass@localhost/evolution\n                    \"\"\",\n                    \"notes\": [\n                        \"Certifique-se de ter Python 3.8+ instalado\",\n                        \"Configure um banco PostgreSQL\",\n                        \"Use secrets seguros em produção\"\n                    ]\n                },\n                {\n                    \"step\": 2,\n                    \"title\": \"Iniciar o Servidor\",\n                    \"description\": \"Execute a API localmente\",\n                    \"code\": \"\"\"\n# Iniciar o servidor\npython main.py\n\n# Ou usando uvicorn diretamente\nuvicorn main:app --host 0.0.0.0 --port 8000 --reload\n                    \"\"\",\n                    \"expected_output\": \"\"\"\nINFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [12345] using statreload\nINFO:     Started server process [12346]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n                    \"\"\",\n                    \"verification\": \"Acesse http://localhost:8000/docs para ver a documentação\"\n                },\n                {\n                    \"step\": 3,\n                    \"title\": \"Primeira Autenticação\",\n                    \"description\": \"Obtenha seu primeiro token de acesso\",\n                    \"code\": \"\"\"\nimport requests\n\n# Dados de login (use suas credenciais)\nlogin_data = {\n    \"username\": \"admin@evolution.com\",\n    \"password\": \"SecurePassword123!\"\n}\n\n# Fazer login\nresponse = requests.post(\n    \"http://localhost:8000/auth/login\",\n    json=login_data\n)\n\nif response.status_code == 200:\n    token_data = response.json()\n    access_token = token_data[\"data\"][\"access_token\"]\n    print(f\"Token obtido: {access_token[:50]}...\")\nelse:\n    print(f\"Erro: {response.text}\")\n                    \"\"\",\n                    \"notes\": [\n                        \"Guarde o token para próximas requisições\",\n                        \"Tokens expiram em 1 hora por padrão\",\n                        \"Use refresh_token para renovar\"\n                    ]\n                },\n                {\n                    \"step\": 4,\n                    \"title\": \"Criar Primeira Instância\",\n                    \"description\": \"Configure uma instância WhatsApp\",\n                    \"code\": \"\"\"\nimport requests\n\n# Headers com autenticação\nheaders = {\n    \"Authorization\": \"Bearer SEU_TOKEN_AQUI\",\n    \"Content-Type\": \"application/json\"\n}\n\n# Dados da instância\ninstance_data = {\n    \"instance_name\": \"minha_primeira_instancia\",\n    \"webhook_url\": \"https://webhook.site/unique-id\",\n    \"webhook_events\": [\"message\", \"status\"],\n    \"settings\": {\n        \"reject_calls\": True,\n        \"always_online\": True\n    }\n}\n\n# Criar instância\nresponse = requests.post(\n    \"http://localhost:8000/instances\",\n    json=instance_data,\n    headers=headers\n)\n\nif response.status_code == 200:\n    instance = response.json()\n    instance_id = instance[\"data\"][\"instance_id\"]\n    qr_code = instance[\"data\"][\"qr_code\"]\n    print(f\"Instância criada: {instance_id}\")\n    print(f\"QR Code: {qr_code[:100]}...\")\nelse:\n    print(f\"Erro: {response.text}\")\n                    \"\"\",\n                    \"notes\": [\n                        \"Use webhook.site para testes\",\n                        \"Escaneie o QR Code no WhatsApp\",\n                        \"Aguarde a conexão ser estabelecida\"\n                    ]\n                },\n                {\n                    \"step\": 5,\n                    \"title\": \"Enviar Primeira Mensagem\",\n                    \"description\": \"Teste o envio de mensagem\",\n                    \"code\": \"\"\"\nimport requests\n\n# Headers com autenticação\nheaders = {\n    \"Authorization\": \"Bearer SEU_TOKEN_AQUI\",\n    \"Content-Type\": \"application/json\"\n}\n\n# Dados da mensagem\nmessage_data = {\n    \"instance_id\": \"SEU_INSTANCE_ID\",\n    \"to\": \"+5511999887766\",  # Substitua pelo seu número\n    \"message\": {\n        \"type\": \"text\",\n        \"content\": \"🎉 Primeira mensagem via Evolution API!\"\n    }\n}\n\n# Enviar mensagem\nresponse = requests.post(\n    \"http://localhost:8000/messages/send\",\n    json=message_data,\n    headers=headers\n)\n\nif response.status_code == 200:\n    result = response.json()\n    message_id = result[\"data\"][\"message_id\"]\n    print(f\"Mensagem enviada! ID: {message_id}\")\nelse:\n    print(f\"Erro: {response.text}\")\n                    \"\"\",\n                    \"notes\": [\n                        \"Use seu próprio número para teste\",\n                        \"Verifique se a instância está conectada\",\n                        \"Monitore o webhook para confirmação\"\n                    ]\n                }\n            ],\n            \"next_steps\": [\n                \"Explore a documentação completa\",\n                \"Configure webhooks personalizados\",\n                \"Implemente agentes inteligentes\",\n                \"Configure WebSockets para tempo real\"\n            ]\n        }\n\n    @staticmethod\n    def get_agno_agent_tutorial() -> Dict[str, Any]:\n        \"\"\"Tutorial de criação de agentes com Agno\"\"\"\n        return {\n            \"title\": \"Agentes Inteligentes com Agno Framework\",\n            \"description\": \"Crie agentes AI poderosos integrados ao WhatsApp\",\n            \"duration\": \"30 minutos\",\n            \"difficulty\": \"Avançado\",\n            \"prerequisites\": [\n                \"Evolution API configurada\",\n                \"Conhecimento básico de Python\",\n                \"API key de provedor AI (OpenAI, Anthropic, etc.)\"\n            ],\n            \"steps\": [\n                {\n                    \"step\": 1,\n                    \"title\": \"Instalar Agno Framework\",\n                    \"description\": \"Configure o ambiente Agno\",\n                    \"code\": \"\"\"\n# Instalar Agno\npip install agno[all]\n\n# Ou instalação específica\npip install agno anthropic openai groq\n\n# Verificar instalação\npython -c \"import agno; print(agno.__version__)\"\n                    \"\"\",\n                    \"notes\": [\n                        \"Use [all] para instalar todos os provedores\",\n                        \"Configure variáveis de ambiente para API keys\",\n                        \"Agno suporta 23+ provedores de AI\"\n                    ]\n                },\n                {\n                    \"step\": 2,\n                    \"title\": \"Agente Nível 1 - Básico\",\n                    \"description\": \"Crie seu primeiro agente com tools\",\n                    \"code\": \"\"\"\n# whatsapp_agent.py\nfrom agno.agent import Agent\nfrom agno.models.anthropic import Claude\nfrom agno.tools.duckduckgo import DuckDuckGoTools\nfrom agno.tools import Tool\nimport requests\nfrom typing import Dict, Any\n\n# Custom tool para Evolution API\nclass EvolutionAPITools(Tool):\n    def __init__(self, api_base_url: str, token: str):\n        super().__init__()\n        self.api_base_url = api_base_url\n        self.headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n    \n    def send_whatsapp_message(self, instance_id: str, to: str, message: str) -> Dict[str, Any]:\n        \"\"\"Enviar mensagem via WhatsApp\"\"\"\n        data = {\n            \"instance_id\": instance_id,\n            \"to\": to,\n            \"message\": {\n                \"type\": \"text\",\n                \"content\": message\n            }\n        }\n        \n        response = requests.post(\n            f\"{self.api_base_url}/messages/send\",\n            json=data,\n            headers=self.headers\n        )\n        \n        return response.json() if response.status_code == 200 else {\"error\": response.text}\n    \n    def get_instance_status(self, instance_id: str) -> Dict[str, Any]:\n        \"\"\"Verificar status da instância\"\"\"\n        response = requests.get(\n            f\"{self.api_base_url}/instances/{instance_id}/status\",\n            headers=self.headers\n        )\n        \n        return response.json() if response.status_code == 200 else {\"error\": response.text}\n\n# Criar agente\nwhatsapp_agent = Agent(\n    name=\"WhatsApp Assistant\",\n    role=\"Assistente inteligente para WhatsApp com pesquisa web\",\n    model=Claude(id=\"claude-sonnet-4-20250514\"),\n    tools=[\n        DuckDuckGoTools(),\n        EvolutionAPITools(\n            api_base_url=\"http://localhost:8000\",\n            token=\"SEU_TOKEN_AQUI\"\n        )\n    ],\n    instructions=[\n        \"Sempre seja útil e educado\",\n        \"Use pesquisa web para informações atuais\",\n        \"Formate respostas de forma clara\",\n        \"Inclua emojis quando apropriado\",\n        \"Mantenha respostas concisas mas informativas\"\n    ],\n    markdown=True\n)\n\n# Função para processar mensagens\ndef process_whatsapp_message(message_content: str, from_number: str, instance_id: str):\n    \"\"\"Processar mensagem recebida\"\"\"\n    try:\n        # Executar agente\n        response = whatsapp_agent.run(\n            f\"Usuário {from_number} perguntou: {message_content}\"\n        )\n        \n        # Enviar resposta\n        whatsapp_agent.tools[1].send_whatsapp_message(\n            instance_id=instance_id,\n            to=from_number,\n            message=response.content\n        )\n        \n        print(f\"✅ Resposta enviada para {from_number}\")\n        \n    except Exception as e:\n        print(f\"❌ Erro ao processar mensagem: {str(e)}\")\n\n# Teste local\nif __name__ == \"__main__\":\n    test_response = whatsapp_agent.run(\"Qual é a previsão do tempo para São Paulo hoje?\")\n    print(test_response.content)\n                    \"\"\",\n                    \"notes\": [\n                        \"Configure sua API key do Claude\",\n                        \"Customize as instructions conforme necessário\",\n                        \"Teste localmente antes de integrar\"\n                    ]\n                },\n                {\n                    \"step\": 3,\n                    \"title\": \"Agente Nível 3 - Com Memory\",\n                    \"description\": \"Adicione memória para contexto persistente\",\n                    \"code\": \"\"\"\n# smart_whatsapp_agent.py\nfrom agno.agent import Agent\nfrom agno.models.anthropic import Claude\nfrom agno.memory import AgentMemory\nfrom agno.tools.duckduckgo import DuckDuckGoTools\nfrom agno.storage.agent import AgentStorage\nimport os\n\n# Configurar storage persistente\nstorage = AgentStorage(\n    table_name=\"whatsapp_agent_storage\",\n    db_url=os.getenv(\"DATABASE_URL\", \"sqlite:///whatsapp_agent.db\")\n)\n\n# Agente com memória\nsmart_agent = Agent(\n    name=\"Smart WhatsApp Assistant\",\n    role=\"Assistente inteligente com memória de conversas\",\n    model=Claude(id=\"claude-sonnet-4-20250514\"),\n    tools=[DuckDuckGoTools(), EvolutionAPITools(...)],\n    memory=AgentMemory(\n        db_url=os.getenv(\"DATABASE_URL\", \"sqlite:///agent_memory.db\"),\n        create_user_memories=True,\n        create_session_summary=True\n    ),\n    storage=storage,\n    instructions=[\n        \"Lembre-se de conversas anteriores com cada usuário\",\n        \"Use o contexto para personalizar respostas\",\n        \"Mantenha um tom consistente\",\n        \"Aprenda preferências do usuário\"\n    ],\n    markdown=True\n)\n\n# Função aprimorada para processar mensagens\ndef process_smart_message(message_content: str, from_number: str, instance_id: str):\n    \"\"\"Processar mensagem com contexto de memória\"\"\"\n    try:\n        # Criar sessão única por usuário\n        session_id = f\"whatsapp_{from_number.replace('+', '')}\"\n        \n        # Executar com memória\n        response = smart_agent.run(\n            message=message_content,\n            session_id=session_id,\n            user_id=from_number\n        )\n        \n        # Enviar resposta\n        smart_agent.tools[1].send_whatsapp_message(\n            instance_id=instance_id,\n            to=from_number,\n            message=response.content\n        )\n        \n        print(f\"✅ Resposta inteligente enviada para {from_number}\")\n        \n        # Log da memória (opcional)\n        memories = smart_agent.memory.get_memories(user_id=from_number)\n        print(f\"📝 Memórias do usuário: {len(memories)} registros\")\n        \n    except Exception as e:\n        print(f\"❌ Erro ao processar mensagem inteligente: {str(e)}\")\n\n# Função para obter resumo de conversas\ndef get_user_conversation_summary(user_id: str) -> str:\n    \"\"\"Obter resumo das conversas do usuário\"\"\"\n    memories = smart_agent.memory.get_memories(user_id=user_id)\n    \n    if not memories:\n        return \"Nenhuma conversa anterior encontrada.\"\n    \n    summary = smart_agent.run(\n        f\"Resuma as principais informações sobre este usuário baseado nas conversas: {memories[-10:]}\",\n        session_id=f\"summary_{user_id}\"\n    )\n    \n    return summary.content\n                    \"\"\",\n                    \"notes\": [\n                        \"Configure DATABASE_URL para produção\",\n                        \"Memória melhora significativamente a experiência\",\n                        \"Use session_id único por usuário\"\n                    ]\n                },\n                {\n                    \"step\": 4,\n                    \"title\": \"Agente Nível 4 - Team Multi-Agent\",\n                    \"description\": \"Crie um team de agentes especializados\",\n                    \"code\": \"\"\"\n# whatsapp_agent_team.py\nfrom agno.agent import Agent\nfrom agno.models.anthropic import Claude\nfrom agno.tools.duckduckgo import DuckDuckGoTools\nfrom agno.tools.yfinance import YFinanceTools\nfrom agno.memory import AgentMemory\n\n# Agente especialista em pesquisa\nresearch_agent = Agent(\n    name=\"Research Specialist\",\n    role=\"Especialista em pesquisa web e informações gerais\",\n    model=Claude(id=\"claude-sonnet-4-20250514\"),\n    tools=[DuckDuckGoTools()],\n    instructions=[\n        \"Foque em informações precisas e atuais\",\n        \"Sempre cite fontes quando possível\",\n        \"Formate informações de forma clara\"\n    ]\n)\n\n# Agente especialista em finanças\nfinance_agent = Agent(\n    name=\"Finance Expert\",\n    role=\"Especialista em mercado financeiro e investimentos\",\n    model=Claude(id=\"claude-sonnet-4-20250514\"),\n    tools=[YFinanceTools()],\n    instructions=[\n        \"Forneça análises financeiras precisas\",\n        \"Inclua dados de mercado atuais\",\n        \"Explique conceitos de forma simples\"\n    ]\n)\n\n# Agente coordenador (Team Leader)\nteam_coordinator = Agent(\n    name=\"WhatsApp Team Coordinator\",\n    role=\"Coordenador de equipe para atendimento WhatsApp\",\n    model=Claude(id=\"claude-sonnet-4-20250514\"),\n    team=[research_agent, finance_agent],\n    tools=[EvolutionAPITools(...)],\n    memory=AgentMemory(\n        db_url=os.getenv(\"DATABASE_URL\", \"sqlite:///team_memory.db\"),\n        create_user_memories=True\n    ),\n    instructions=[\n        \"Analise a pergunta e delegue para o agente apropriado\",\n        \"Para pesquisas gerais, use o Research Specialist\",\n        \"Para questões financeiras, use o Finance Expert\",\n        \"Combine respostas quando necessário\",\n        \"Mantenha respostas organizadas e úteis\"\n    ],\n    markdown=True\n)\n\n# Função para processar com team\ndef process_team_message(message_content: str, from_number: str, instance_id: str):\n    \"\"\"Processar mensagem com team de agentes\"\"\"\n    try:\n        session_id = f\"team_whatsapp_{from_number.replace('+', '')}\"\n        \n        # Executar team coordinator\n        response = team_coordinator.run(\n            message=f\"Usuário {from_number} perguntou: {message_content}\",\n            session_id=session_id,\n            user_id=from_number\n        )\n        \n        # Enviar resposta coordenada\n        team_coordinator.tools[0].send_whatsapp_message(\n            instance_id=instance_id,\n            to=from_number,\n            message=response.content\n        )\n        \n        print(f\"✅ Resposta do team enviada para {from_number}\")\n        print(f\"🤖 Agentes utilizados: {len(team_coordinator.team)} especialistas\")\n        \n    except Exception as e:\n        print(f\"❌ Erro no team: {str(e)}\")\n\n# Exemplo de uso\nif __name__ == \"__main__\":\n    # Teste de pesquisa geral\n    test1 = team_coordinator.run(\"Qual é a capital da França?\")\n    print(\"Pesquisa:\", test1.content)\n    \n    # Teste financeiro\n    test2 = team_coordinator.run(\"Qual é o preço atual da ação da Apple?\")\n    print(\"Finanças:\", test2.content)\n                    \"\"\",\n                    \"notes\": [\n                        \"Teams são ideais para domínios específicos\",\n                        \"Coordinator delega automaticamente\",\n                        \"Performance ~10,000x mais rápida que LangGraph\"\n                    ]\n                },\n                {\n                    \"step\": 5,\n                    \"title\": \"Integração com Webhook\",\n                    \"description\": \"Conecte o agente ao webhook da Evolution API\",\n                    \"code\": \"\"\"\n# webhook_agno_integration.py\nfrom flask import Flask, request, jsonify\nfrom whatsapp_agent_team import team_coordinator, process_team_message\nimport json\nimport threading\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n# Configurações\nCONFIG = {\n    \"api_base_url\": \"http://localhost:8000\",\n    \"token\": \"SEU_TOKEN_AQUI\",\n    \"instance_id\": \"SEU_INSTANCE_ID\"\n}\n\n@app.route('/webhook/agno', methods=['POST'])\ndef agno_webhook():\n    \"\"\"Webhook integrado com Agno\"\"\"\n    try:\n        data = request.get_json()\n        event_type = data.get('event')\n        \n        print(f\"[{datetime.now()}] Evento Agno: {event_type}\")\n        \n        if event_type == 'message.received':\n            # Processar em thread separada para não bloquear\n            thread = threading.Thread(\n                target=handle_agno_message,\n                args=(data,)\n            )\n            thread.start()\n        \n        return jsonify({\"status\": \"success\", \"processed_by\": \"agno\"}), 200\n        \n    except Exception as e:\n        print(f\"Erro no webhook Agno: {str(e)}\")\n        return jsonify({\"error\": str(e)}), 500\n\ndef handle_agno_message(webhook_data):\n    \"\"\"Processar mensagem com Agno\"\"\"\n    try:\n        message_data = webhook_data.get('data', {})\n        instance_id = webhook_data.get('instance_id')\n        from_number = message_data.get('from')\n        content = message_data.get('content', '')\n        message_type = message_data.get('message_type')\n        \n        # Só processar mensagens de texto\n        if message_type != 'text':\n            return\n        \n        # Evitar loops (não responder a si mesmo)\n        if is_bot_number(from_number):\n            return\n        \n        print(f\"🤖 Processando com Agno: {content[:50]}...\")\n        \n        # Processar com team de agentes\n        process_team_message(\n            message_content=content,\n            from_number=from_number,\n            instance_id=instance_id\n        )\n        \n    except Exception as e:\n        print(f\"Erro ao processar com Agno: {str(e)}\")\n\ndef is_bot_number(number):\n    \"\"\"Verificar se é o número do bot\"\"\"\n    # Implementar lógica para identificar próprio número\n    return False\n\n# Endpoint para estatísticas\n@app.route('/agno/stats', methods=['GET'])\ndef agno_stats():\n    \"\"\"Estatísticas do agente\"\"\"\n    try:\n        # Obter memórias e estatísticas\n        total_users = len(team_coordinator.memory.get_all_users()) if team_coordinator.memory else 0\n        \n        stats = {\n            \"agent_name\": team_coordinator.name,\n            \"total_users\": total_users,\n            \"team_size\": len(team_coordinator.team),\n            \"model\": team_coordinator.model.id,\n            \"status\": \"active\",\n            \"last_update\": datetime.now().isoformat()\n        }\n        \n        return jsonify(stats), 200\n        \n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# Endpoint para conversar diretamente\n@app.route('/agno/chat', methods=['POST'])\ndef agno_chat():\n    \"\"\"Chat direto com o agente\"\"\"\n    try:\n        data = request.get_json()\n        message = data.get('message')\n        user_id = data.get('user_id', 'web_user')\n        \n        response = team_coordinator.run(\n            message=message,\n            session_id=f\"web_{user_id}\",\n            user_id=user_id\n        )\n        \n        return jsonify({\n            \"response\": response.content,\n            \"agent\": team_coordinator.name,\n            \"timestamp\": datetime.now().isoformat()\n        }), 200\n        \n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\nif __name__ == '__main__':\n    print(\"🚀 Iniciando servidor Agno + Evolution API\")\n    print(f\"🤖 Agente: {team_coordinator.name}\")\n    print(f\"👥 Team: {len(team_coordinator.team)} especialistas\")\n    app.run(host='0.0.0.0', port=5001, debug=True)\n                    \"\"\",\n                    \"notes\": [\n                        \"Use threading para não bloquear webhook\",\n                        \"Implemente rate limiting se necessário\",\n                        \"Monitore performance e memória\"\n                    ]\n                }\n            ],\n            \"performance_tips\": [\n                \"Agno é ~10,000x mais rápido que LangGraph\",\n                \"Use teams quando precisar de mais de 5-7 tools\",\n                \"Memory melhora significativamente a experiência\",\n                \"Structured outputs garantem reliability\",\n                \"Async operations para máxima performance\"\n            ]\n        }\n\n    @staticmethod\n    def get_websocket_tutorial() -> Dict[str, Any]:\n        \"\"\"Tutorial de WebSockets para tempo real\"\"\"\n        return {\n            \"title\": \"WebSockets para Comunicação em Tempo Real\",\n            \"description\": \"Implemente comunicação bidirecional em tempo real\",\n            \"duration\": \"25 minutos\",\n            \"difficulty\": \"Intermediário\",\n            \"steps\": [\n                {\n                    \"step\": 1,\n                    \"title\": \"Cliente WebSocket Básico\",\n                    \"description\": \"Conecte-se aos WebSockets da Evolution API\",\n                    \"code\": \"\"\"\n# websocket_client.py\nimport asyncio\nimport websockets\nimport json\nfrom datetime import datetime\n\nclass EvolutionWebSocketClient:\n    def __init__(self, ws_url, token):\n        self.ws_url = ws_url\n        self.token = token\n        self.websocket = None\n        self.is_connected = False\n    \n    async def connect(self):\n        \"\"\"Conectar ao WebSocket\"\"\"\n        try:\n            # Headers de autenticação\n            headers = {\n                \"Authorization\": f\"Bearer {self.token}\"\n            }\n            \n            self.websocket = await websockets.connect(\n                self.ws_url,\n                extra_headers=headers\n            )\n            \n            self.is_connected = True\n            print(f\"✅ Conectado ao WebSocket: {self.ws_url}\")\n            \n            # Enviar autenticação\n            await self.authenticate()\n            \n        except Exception as e:\n            print(f\"❌ Erro na conexão: {str(e)}\")\n            self.is_connected = False\n    \n    async def authenticate(self):\n        \"\"\"Autenticar conexão\"\"\"\n        auth_message = {\n            \"type\": \"auth\",\n            \"data\": {\n                \"token\": self.token\n            }\n        }\n        \n        await self.send_message(auth_message)\n    \n    async def send_message(self, message):\n        \"\"\"Enviar mensagem\"\"\"\n        if self.websocket and self.is_connected:\n            await self.websocket.send(json.dumps(message))\n    \n    async def listen(self):\n        \"\"\"Escutar mensagens\"\"\"\n        try:\n            async for message in self.websocket:\n                data = json.loads(message)\n                await self.handle_message(data)\n                \n        except websockets.exceptions.ConnectionClosed:\n            print(\"🔌 Conexão WebSocket fechada\")\n            self.is_connected = False\n        except Exception as e:\n            print(f\"❌ Erro ao escutar: {str(e)}\")\n    \n    async def handle_message(self, data):\n        \"\"\"Processar mensagem recebida\"\"\"\n        event_type = data.get('type')\n        timestamp = datetime.now().strftime('%H:%M:%S')\n        \n        print(f\"[{timestamp}] 📨 {event_type}: {data}\")\n        \n        # Processar diferentes tipos de eventos\n        if event_type == 'message.received':\n            await self.handle_new_message(data)\n        elif event_type == 'instance.status':\n            await self.handle_instance_status(data)\n        elif event_type == 'agent.response':\n            await self.handle_agent_response(data)\n    \n    async def handle_new_message(self, data):\n        \"\"\"Processar nova mensagem\"\"\"\n        message_data = data.get('data', {})\n        from_number = message_data.get('from')\n        content = message_data.get('content')\n        \n        print(f\"📱 Nova mensagem de {from_number}: {content}\")\n    \n    async def handle_instance_status(self, data):\n        \"\"\"Processar status da instância\"\"\"\n        status_data = data.get('data', {})\n        instance_id = status_data.get('instance_id')\n        status = status_data.get('status')\n        \n        print(f\"🔄 Instância {instance_id}: {status}\")\n    \n    async def handle_agent_response(self, data):\n        \"\"\"Processar resposta do agente\"\"\"\n        agent_data = data.get('data', {})\n        agent_name = agent_data.get('agent_name')\n        response = agent_data.get('response')\n        \n        print(f\"🤖 {agent_name}: {response}\")\n    \n    async def subscribe_to_events(self, events):\n        \"\"\"Subscrever a eventos específicos\"\"\"\n        subscribe_message = {\n            \"type\": \"subscribe\",\n            \"data\": {\n                \"events\": events\n            }\n        }\n        \n        await self.send_message(subscribe_message)\n        print(f\"📡 Subscrito aos eventos: {events}\")\n\n# Uso do cliente\nasync def main():\n    client = EvolutionWebSocketClient(\n        ws_url=\"ws://localhost:8000/ws\",\n        token=\"SEU_TOKEN_AQUI\"\n    )\n    \n    await client.connect()\n    \n    if client.is_connected:\n        # Subscrever a eventos\n        await client.subscribe_to_events([\n            \"message.received\",\n            \"instance.status\",\n            \"agent.response\"\n        ])\n        \n        # Escutar mensagens\n        await client.listen()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n                    \"\"\",\n                    \"notes\": [\n                        \"Use asyncio para operações assíncronas\",\n                        \"Implemente reconexão automática\",\n                        \"Gerencie subscrições de eventos\"\n                    ]\n                }\n            ]\n        }\n\n    @staticmethod\n    def estimate_completion_time(tutorial_name: str) -> str:\n        \"\"\"Estimar tempo de conclusão\"\"\"\n        times = {\n            \"quick_start\": \"10 minutos\",\n            \"agno_agent\": \"30 minutos\",\n            \"websocket\": \"25 minutos\",\n            \"webhook\": \"20 minutos\"\n        }\n        return times.get(tutorial_name, \"Tempo não estimado\")\n\n    @staticmethod\n    def generate_code_snippets(language: str = \"python\") -> Dict[str, str]:\n        \"\"\"Gerar snippets de código para diferentes linguagens\"\"\"\n        if language == \"python\":\n            return {\n                \"auth\": \"\"\"\nimport requests\n\nresponse = requests.post(\n    'http://localhost:8000/auth/login',\n    json={'username': 'user', 'password': 'pass'}\n)\ntoken = response.json()['data']['access_token']\n                \"\"\",\n                \"send_message\": \"\"\"\nheaders = {'Authorization': f'Bearer {token}'}\ndata = {\n    'instance_id': 'instance_id',\n    'to': '+5511999887766',\n    'message': {'type': 'text', 'content': 'Hello!'}\n}\nresponse = requests.post(\n    'http://localhost:8000/messages/send',\n    json=data, headers=headers\n)\n                \"\"\"\n            }\n        return {}\n\n\n# Funções utilitárias\ndef validate_prerequisites(tutorial_name: str) -> List[str]:\n    \"\"\"Validar pré-requisitos do tutorial\"\"\"\n    missing = []\n    \n    try:\n        import requests\n    except ImportError:\n        missing.append(\"requests library\")\n    \n    if tutorial_name == \"agno_agent\":\n        try:\n            import agno\n        except ImportError:\n            missing.append(\"agno framework\")\n    \n    return missing\n\n\ndef generate_custom_tutorial(requirements: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Gerar tutorial personalizado\"\"\"\n    return {\n        \"title\": f\"Tutorial Personalizado: {requirements.get('title', 'Custom')}\",\n        \"description\": requirements.get('description', 'Tutorial gerado automaticamente'),\n        \"steps\": requirements.get('steps', []),\n        \"difficulty\": requirements.get('difficulty', 'Intermediário'),\n        \"duration\": requirements.get('duration', '15 minutos')\n    }\n