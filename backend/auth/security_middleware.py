"""\nMiddleware de Seguran√ßa para Evolution API\n\nImplementa funcionalidades avan√ßadas de seguran√ßa:\n- Rate limiting inteligente\n- Auditoria de requisi√ß√µes\n- Detec√ß√£o de atividades suspeitas\n- Headers de seguran√ßa\n- Prote√ß√£o contra ataques comuns\n- Monitoramento em tempo real\n\nAutor: AgnoMaster - Evolution API Security Expert\nData: 2025-01-24\n"""\n\nimport time\nimport json\nimport hashlib\nimport asyncio\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Dict, List, Optional, Any, Callable\nfrom collections import defaultdict, deque\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport ipaddress\nimport re\n\nfrom fastapi import Request, Response, HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.types import ASGIApp\nfrom loguru import logger\nimport redis.asyncio as redis\n\nfrom .security_config import EvolutionSecuritySettings, SecurityLevel\nfrom .jwt_auth import User, AuthenticationError\n\n\nclass ThreatLevel(str, Enum):\n    \"\"\"N√≠veis de amea√ßa detectados\"\"\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\n\nclass AttackType(str, Enum):\n    \"\"\"Tipos de ataques detectados\"\"\"\n    BRUTE_FORCE = \"brute_force\"\n    SQL_INJECTION = \"sql_injection\"\n    XSS = \"xss\"\n    CSRF = \"csrf\"\n    DDoS = \"ddos\"\n    RATE_LIMIT_ABUSE = \"rate_limit_abuse\"\n    SUSPICIOUS_PATTERN = \"suspicious_pattern\"\n    MALFORMED_REQUEST = \"malformed_request\"\n\n\n@dataclass\nclass SecurityEvent:\n    \"\"\"Evento de seguran√ßa detectado\"\"\"\n    timestamp: datetime\n    event_type: AttackType\n    threat_level: ThreatLevel\n    source_ip: str\n    user_agent: str\n    endpoint: str\n    method: str\n    details: Dict[str, Any] = field(default_factory=dict)\n    user_id: Optional[str] = None\n    blocked: bool = False\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"timestamp\": self.timestamp.isoformat(),\n            \"event_type\": self.event_type.value,\n            \"threat_level\": self.threat_level.value,\n            \"source_ip\": self.source_ip,\n            \"user_agent\": self.user_agent,\n            \"endpoint\": self.endpoint,\n            \"method\": self.method,\n            \"details\": self.details,\n            \"user_id\": self.user_id,\n            \"blocked\": self.blocked\n        }\n\n\n@dataclass\nclass RateLimitBucket:\n    \"\"\"Bucket para rate limiting\"\"\"\n    requests: deque = field(default_factory=deque)\n    blocked_until: Optional[datetime] = None\n    violation_count: int = 0\n    \n    def is_blocked(self) -> bool:\n        if self.blocked_until and datetime.now(timezone.utc) < self.blocked_until:\n            return True\n        return False\n    \n    def add_request(self, timestamp: datetime):\n        self.requests.append(timestamp)\n    \n    def cleanup_old_requests(self, window_size: timedelta):\n        cutoff = datetime.now(timezone.utc) - window_size\n        while self.requests and self.requests[0] < cutoff:\n            self.requests.popleft()\n    \n    def get_request_count(self) -> int:\n        return len(self.requests)\n\n\nclass SecurityDetector:\n    \"\"\"\n    Detector de amea√ßas e atividades suspeitas\n    \"\"\"\n    \n    def __init__(self):\n        # Padr√µes de ataques conhecidos\n        self.sql_injection_patterns = [\n            r\"(union|select|insert|update|delete|drop|create|alter)\\s+\",\n            r\"(or|and)\\s+\\d+\\s*=\\s*\\d+\",\n            r\"'\\s*(or|and)\\s*'\\w*'\\s*=\\s*'\\w*'\",\n            r\"\\b(exec|execute|sp_|xp_)\\w+\",\n            r\"(--|#|/\\*|\\*/)\",\n            r\"\\b(information_schema|sysobjects|syscolumns)\\b\"\n        ]\n        \n        self.xss_patterns = [\n            r\"<script[^>]*>.*?</script>\",\n            r\"javascript:\\w+\",\n            r\"on\\w+\\s*=\\s*[\"'][^\"']*[\"']\",\n            r\"<iframe[^>]*>.*?</iframe>\",\n            r\"<object[^>]*>.*?</object>\",\n            r\"<embed[^>]*>.*?</embed>\"\n        ]\n        \n        self.suspicious_patterns = [\n            r\"\\.\\.[\\/\\\\]+\",  # Path traversal\n            r\"\\b(cmd|powershell|bash|sh)\\b\",  # Command injection\n            r\"\\b(eval|exec|system|shell_exec)\\b\",  # Code injection\n            r\"\\b(file|ftp|http|https):\\/\\/\",  # Protocol injection\n            r\"\\b(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0)\\b\"  # Local access attempts\n        ]\n        \n        # Compile patterns for performance\n        self.compiled_sql_patterns = [re.compile(p, re.IGNORECASE) for p in self.sql_injection_patterns]\n        self.compiled_xss_patterns = [re.compile(p, re.IGNORECASE) for p in self.xss_patterns]\n        self.compiled_suspicious_patterns = [re.compile(p, re.IGNORECASE) for p in self.suspicious_patterns]\n    \n    def detect_sql_injection(self, text: str) -> bool:\n        \"\"\"Detecta tentativas de SQL injection\"\"\"\n        for pattern in self.compiled_sql_patterns:\n            if pattern.search(text):\n                return True\n        return False\n    \n    def detect_xss(self, text: str) -> bool:\n        \"\"\"Detecta tentativas de XSS\"\"\"\n        for pattern in self.compiled_xss_patterns:\n            if pattern.search(text):\n                return True\n        return False\n    \n    def detect_suspicious_activity(self, text: str) -> bool:\n        \"\"\"Detecta atividades suspeitas\"\"\"\n        for pattern in self.compiled_suspicious_patterns:\n            if pattern.search(text):\n                return True\n        return False\n    \n    def analyze_request(self, request: Request) -> List[SecurityEvent]:\n        \"\"\"Analisa uma requisi√ß√£o em busca de amea√ßas\"\"\"\n        events = []\n        now = datetime.now(timezone.utc)\n        \n        # Extrai dados da requisi√ß√£o\n        source_ip = self._get_client_ip(request)\n        user_agent = request.headers.get(\"user-agent\", \"\")\n        endpoint = str(request.url.path)\n        method = request.method\n        \n        # Analisa URL\n        url_str = str(request.url)\n        if self.detect_sql_injection(url_str):\n            events.append(SecurityEvent(\n                timestamp=now,\n                event_type=AttackType.SQL_INJECTION,\n                threat_level=ThreatLevel.HIGH,\n                source_ip=source_ip,\n                user_agent=user_agent,\n                endpoint=endpoint,\n                method=method,\n                details={\"location\": \"url\", \"content\": url_str}\n            ))\n        \n        if self.detect_xss(url_str):\n            events.append(SecurityEvent(\n                timestamp=now,\n                event_type=AttackType.XSS,\n                threat_level=ThreatLevel.HIGH,\n                source_ip=source_ip,\n                user_agent=user_agent,\n                endpoint=endpoint,\n                method=method,\n                details={\"location\": \"url\", \"content\": url_str}\n            ))\n        \n        if self.detect_suspicious_activity(url_str):\n            events.append(SecurityEvent(\n                timestamp=now,\n                event_type=AttackType.SUSPICIOUS_PATTERN,\n                threat_level=ThreatLevel.MEDIUM,\n                source_ip=source_ip,\n                user_agent=user_agent,\n                endpoint=endpoint,\n                method=method,\n                details={\"location\": \"url\", \"content\": url_str}\n            ))\n        \n        # Analisa headers\n        for header_name, header_value in request.headers.items():\n            if self.detect_sql_injection(header_value) or self.detect_xss(header_value):\n                events.append(SecurityEvent(\n                    timestamp=now,\n                    event_type=AttackType.MALFORMED_REQUEST,\n                    threat_level=ThreatLevel.MEDIUM,\n                    source_ip=source_ip,\n                    user_agent=user_agent,\n                    endpoint=endpoint,\n                    method=method,\n                    details={\"location\": f\"header:{header_name}\", \"content\": header_value}\n                ))\n        \n        return events\n    \n    def _get_client_ip(self, request: Request) -> str:\n        \"\"\"Extrai o IP real do cliente\"\"\"\n        # Verifica headers de proxy\n        forwarded_for = request.headers.get(\"x-forwarded-for\")\n        if forwarded_for:\n            return forwarded_for.split(\",\")[0].strip()\n        \n        real_ip = request.headers.get(\"x-real-ip\")\n        if real_ip:\n            return real_ip\n        \n        return request.client.host if request.client else \"unknown\"\n\n\nclass SecurityMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Middleware principal de seguran√ßa\n    \"\"\"\n    \n    def __init__(\n        self,\n        app: ASGIApp,\n        settings: EvolutionSecuritySettings,\n        redis_client: Optional[redis.Redis] = None\n    ):\n        super().__init__(app)\n        self.settings = settings\n        self.redis_client = redis_client\n        self.detector = SecurityDetector()\n        \n        # Cache em mem√≥ria\n        self.rate_limit_buckets: Dict[str, RateLimitBucket] = defaultdict(RateLimitBucket)\n        self.blocked_ips: Dict[str, datetime] = {}\n        self.security_events: List[SecurityEvent] = []\n        \n        # Configura√ß√µes\n        self.rate_limit_config = settings.get_rate_limit_config()\n        self.security_config = settings.get_security_config()\n        \n        # Cleanup task\n        self._cleanup_task = None\n        self._start_cleanup_task()\n        \n        logger.info(\"üõ°Ô∏è SecurityMiddleware inicializado\")\n    \n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        \"\"\"Processa a requisi√ß√£o atrav√©s do middleware de seguran√ßa\"\"\"\n        start_time = time.time()\n        \n        try:\n            # 1. Verifica IP bloqueado\n            client_ip = self._get_client_ip(request)\n            if await self._is_ip_blocked(client_ip):\n                return self._create_blocked_response(\"IP bloqueado por atividade suspeita\")\n            \n            # 2. Verifica rate limiting\n            if not await self._check_rate_limit(request):\n                await self._log_security_event(SecurityEvent(\n                    timestamp=datetime.now(timezone.utc),\n                    event_type=AttackType.RATE_LIMIT_ABUSE,\n                    threat_level=ThreatLevel.MEDIUM,\n                    source_ip=client_ip,\n                    user_agent=request.headers.get(\"user-agent\", \"\"),\n                    endpoint=str(request.url.path),\n                    method=request.method,\n                    blocked=True\n                ))\n                return self._create_rate_limit_response()\n            \n            # 3. Detecta amea√ßas\n            security_events = self.detector.analyze_request(request)\n            for event in security_events:\n                await self._handle_security_event(event, request)\n            \n            # 4. Adiciona headers de seguran√ßa\n            response = await call_next(request)\n            self._add_security_headers(response)\n            \n            # 5. Log da requisi√ß√£o\n            await self._log_request(request, response, time.time() - start_time)\n            \n            return response\n            \n        except Exception as e:\n            logger.error(f\"Erro no SecurityMiddleware: {e}\")\n            # Em caso de erro, permite a requisi√ß√£o continuar\n            response = await call_next(request)\n            self._add_security_headers(response)\n            return response\n    \n    async def _check_rate_limit(self, request: Request) -> bool:\n        \"\"\"Verifica rate limiting\"\"\"\n        if not self.rate_limit_config.enabled:\n            return True\n        \n        client_ip = self._get_client_ip(request)\n        endpoint = str(request.url.path)\n        \n        # Determina o limite baseado no endpoint\n        limit = self._get_endpoint_limit(endpoint)\n        \n        # Cria chave √∫nica para o bucket\n        bucket_key = f\"{client_ip}:{endpoint}\"\n        bucket = self.rate_limit_buckets[bucket_key]\n        \n        # Verifica se est√° bloqueado\n        if bucket.is_blocked():\n            return False\n        \n        # Limpa requisi√ß√µes antigas\n        window = timedelta(seconds=self.rate_limit_config.window_size)\n        bucket.cleanup_old_requests(window)\n        \n        # Verifica limite\n        if bucket.get_request_count() >= limit:\n            # Bloqueia temporariamente\n            bucket.blocked_until = datetime.now(timezone.utc) + timedelta(\n                seconds=self.rate_limit_config.block_duration\n            )\n            bucket.violation_count += 1\n            \n            # Se muitas viola√ß√µes, bloqueia o IP\n            if bucket.violation_count >= 3:\n                await self._block_ip(client_ip, timedelta(hours=1))\n            \n            return False\n        \n        # Adiciona a requisi√ß√£o\n        bucket.add_request(datetime.now(timezone.utc))\n        return True\n    \n    async def _handle_security_event(self, event: SecurityEvent, request: Request):\n        \"\"\"Trata um evento de seguran√ßa\"\"\"\n        # Determina se deve bloquear\n        should_block = self._should_block_event(event)\n        event.blocked = should_block\n        \n        # Log do evento\n        await self._log_security_event(event)\n        \n        # A√ß√µes baseadas no n√≠vel de amea√ßa\n        if event.threat_level == ThreatLevel.CRITICAL or should_block:\n            await self._block_ip(event.source_ip, timedelta(hours=24))\n        elif event.threat_level == ThreatLevel.HIGH:\n            await self._block_ip(event.source_ip, timedelta(hours=1))\n        \n        # Alerta para administradores\n        if event.threat_level in [ThreatLevel.HIGH, ThreatLevel.CRITICAL]:\n            await self._send_security_alert(event)\n    \n    def _should_block_event(self, event: SecurityEvent) -> bool:\n        \"\"\"Determina se um evento deve resultar em bloqueio\"\"\"\n        if self.settings.security_level == SecurityLevel.CRITICAL:\n            return event.threat_level in [ThreatLevel.MEDIUM, ThreatLevel.HIGH, ThreatLevel.CRITICAL]\n        elif self.settings.security_level == SecurityLevel.HIGH:\n            return event.threat_level in [ThreatLevel.HIGH, ThreatLevel.CRITICAL]\n        elif self.settings.security_level == SecurityLevel.MEDIUM:\n            return event.threat_level == ThreatLevel.CRITICAL\n        else:\n            return False\n    \n    async def _block_ip(self, ip: str, duration: timedelta):\n        \"\"\"Bloqueia um IP por um per√≠odo\"\"\"\n        blocked_until = datetime.now(timezone.utc) + duration\n        self.blocked_ips[ip] = blocked_until\n        \n        if self.redis_client:\n            await self.redis_client.setex(\n                f\"blocked_ip:{ip}\",\n                int(duration.total_seconds()),\n                blocked_until.isoformat()\n            )\n        \n        logger.warning(f\"üö´ IP bloqueado: {ip} at√© {blocked_until}\")\n    \n    async def _is_ip_blocked(self, ip: str) -> bool:\n        \"\"\"Verifica se um IP est√° bloqueado\"\"\"\n        # Verifica cache local\n        if ip in self.blocked_ips:\n            if datetime.now(timezone.utc) < self.blocked_ips[ip]:\n                return True\n            else:\n                del self.blocked_ips[ip]\n        \n        # Verifica Redis\n        if self.redis_client:\n            blocked_until_str = await self.redis_client.get(f\"blocked_ip:{ip}\")\n            if blocked_until_str:\n                blocked_until = datetime.fromisoformat(blocked_until_str.decode())\n                if datetime.now(timezone.utc) < blocked_until:\n                    self.blocked_ips[ip] = blocked_until\n                    return True\n        \n        return False\n    \n    def _get_endpoint_limit(self, endpoint: str) -> int:\n        \"\"\"Retorna o limite de rate para um endpoint\"\"\"\n        # Limites espec√≠ficos por endpoint\n        endpoint_limits = {\n            \"/auth/login\": self.rate_limit_config.auth_limit,\n            \"/auth/register\": self.rate_limit_config.auth_limit,\n            \"/webhook\": self.rate_limit_config.webhook_limit,\n        }\n        \n        for pattern, limit in endpoint_limits.items():\n            if pattern in endpoint:\n                return limit\n        \n        return self.rate_limit_config.default_limit\n    \n    def _add_security_headers(self, response: Response):\n        \"\"\"Adiciona headers de seguran√ßa\"\"\"\n        security_headers = {\n            \"X-Content-Type-Options\": \"nosniff\",\n            \"X-Frame-Options\": \"DENY\",\n            \"X-XSS-Protection\": \"1; mode=block\",\n            \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n            \"Content-Security-Policy\": \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'\",\n            \"Permissions-Policy\": \"geolocation=(), microphone=(), camera=()\",\n            \"X-Permitted-Cross-Domain-Policies\": \"none\"\n        }\n        \n        # HSTS se SSL estiver habilitado\n        if self.settings.ssl_enabled:\n            ssl_config = self.settings.get_ssl_config()\n            if ssl_config.hsts_enabled:\n                hsts_header = f\"max-age={ssl_config.hsts_max_age}\"\n                if ssl_config.hsts_include_subdomains:\n                    hsts_header += \"; includeSubDomains\"\n                if ssl_config.hsts_preload:\n                    hsts_header += \"; preload\"\n                security_headers[\"Strict-Transport-Security\"] = hsts_header\n        \n        for header, value in security_headers.items():\n            response.headers[header] = value\n    \n    def _create_blocked_response(self, message: str) -> JSONResponse:\n        \"\"\"Cria resposta para IP bloqueado\"\"\"\n        return JSONResponse(\n            status_code=status.HTTP_403_FORBIDDEN,\n            content={\n                \"error\": \"access_denied\",\n                \"message\": message,\n                \"timestamp\": datetime.now(timezone.utc).isoformat()\n            }\n        )\n    \n    def _create_rate_limit_response(self) -> JSONResponse:\n        \"\"\"Cria resposta para rate limit excedido\"\"\"\n        return JSONResponse(\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n            content={\n                \"error\": \"rate_limit_exceeded\",\n                \"message\": \"Muitas requisi√ß√µes. Tente novamente mais tarde.\",\n                \"timestamp\": datetime.now(timezone.utc).isoformat()\n            },\n            headers={\n                \"Retry-After\": str(self.rate_limit_config.block_duration)\n            }\n        )\n    \n    async def _log_security_event(self, event: SecurityEvent):\n        \"\"\"Registra um evento de seguran√ßa\"\"\"\n        self.security_events.append(event)\n        \n        # Log estruturado\n        logger.warning(\n            f\"üö® Evento de seguran√ßa: {event.event_type.value} | \"\n            f\"N√≠vel: {event.threat_level.value} | \"\n            f\"IP: {event.source_ip} | \"\n            f\"Endpoint: {event.endpoint} | \"\n            f\"Bloqueado: {event.blocked}\",\n            extra={\"security_event\": event.to_dict()}\n        )\n        \n        # Salva no Redis se dispon√≠vel\n        if self.redis_client:\n            await self.redis_client.lpush(\n                \"security_events\",\n                json.dumps(event.to_dict())\n            )\n            # Mant√©m apenas os √∫ltimos 10000 eventos\n            await self.redis_client.ltrim(\"security_events\", 0, 9999)\n    \n    async def _log_request(self, request: Request, response: Response, duration: float):\n        \"\"\"Registra uma requisi√ß√£o\"\"\"\n        if self.settings.audit_enabled:\n            log_data = {\n                \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                \"method\": request.method,\n                \"path\": str(request.url.path),\n                \"query_params\": dict(request.query_params),\n                \"status_code\": response.status_code,\n                \"duration_ms\": round(duration * 1000, 2),\n                \"client_ip\": self._get_client_ip(request),\n                \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n                \"content_length\": response.headers.get(\"content-length\", 0)\n            }\n            \n            logger.info(\"üìä Requisi√ß√£o processada\", extra={\"request_log\": log_data})\n    \n    async def _send_security_alert(self, event: SecurityEvent):\n        \"\"\"Envia alerta de seguran√ßa\"\"\"\n        # Implementar integra√ß√£o com sistema de alertas\n        # (email, Slack, webhook, etc.)\n        logger.critical(\n            f\"üö® ALERTA DE SEGURAN√áA: {event.event_type.value} | \"\n            f\"IP: {event.source_ip} | \"\n            f\"Endpoint: {event.endpoint}\"\n        )\n    \n    def _get_client_ip(self, request: Request) -> str:\n        \"\"\"Extrai o IP real do cliente\"\"\"\n        return self.detector._get_client_ip(request)\n    \n    def _start_cleanup_task(self):\n        \"\"\"Inicia task de limpeza peri√≥dica\"\"\"\n        async def cleanup():\n            while True:\n                try:\n                    await asyncio.sleep(300)  # 5 minutos\n                    await self._cleanup_old_data()\n                except Exception as e:\n                    logger.error(f\"Erro na limpeza: {e}\")\n        \n        self._cleanup_task = asyncio.create_task(cleanup())\n    \n    async def _cleanup_old_data(self):\n        \"\"\"Limpa dados antigos\"\"\"\n        now = datetime.now(timezone.utc)\n        \n        # Remove IPs bloqueados expirados\n        expired_ips = [\n            ip for ip, blocked_until in self.blocked_ips.items()\n            if now >= blocked_until\n        ]\n        for ip in expired_ips:\n            del self.blocked_ips[ip]\n        \n        # Remove eventos antigos (mant√©m √∫ltimos 1000)\n        if len(self.security_events) > 1000:\n            self.security_events = self.security_events[-1000:]\n        \n        # Limpa buckets de rate limit antigos\n        window = timedelta(seconds=self.rate_limit_config.window_size * 2)\n        for bucket in self.rate_limit_buckets.values():\n            bucket.cleanup_old_requests(window)\n        \n        logger.debug(\"üßπ Limpeza de dados de seguran√ßa conclu√≠da\")\n\n\n# Fun√ß√£o para criar o middleware\ndef create_security_middleware(\n    settings: EvolutionSecuritySettings,\n    redis_client: Optional[redis.Redis] = None\n) -> SecurityMiddleware:\n    \"\"\"Cria uma inst√¢ncia do middleware de seguran√ßa\"\"\"\n    return lambda app: SecurityMiddleware(app, settings, redis_client)\n"}}