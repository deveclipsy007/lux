"""\nSistema de Autentica√ß√£o JWT para Evolution API\n\nImplementa autentica√ß√£o robusta com JWT tokens, API keys e controle de acesso\nbaseado em roles. Inclui funcionalidades de seguran√ßa como rate limiting,\nblacklist de tokens e valida√ß√£o de integridade.\n\nFuncionalidades:\n- Gera√ß√£o e valida√ß√£o de JWT tokens\n- Sistema de API keys com scopes\n- Rate limiting por usu√°rio/IP\n- Blacklist de tokens revogados\n- Controle de acesso baseado em roles\n- Auditoria de autentica√ß√£o\n\nAutor: AgnoMaster - Evolution API Security Expert\nData: 2025-01-24\n"""\n\nimport jwt\nimport secrets\nimport hashlib\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, List, Optional, Any, Union\nfrom enum import Enum\nfrom dataclasses import dataclass, field\nimport asyncio\nfrom collections import defaultdict\n\nfrom fastapi import HTTPException, status, Request\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, Field\nfrom loguru import logger\nimport redis.asyncio as redis\n\n\nclass UserRole(str, Enum):\n    \"\"\"Roles de usu√°rio no sistema\"\"\"\n    ADMIN = \"admin\"\n    DEVELOPER = \"developer\"\n    AGENT_MANAGER = \"agent_manager\"\n    API_USER = \"api_user\"\n    READONLY = \"readonly\"\n\n\nclass TokenType(str, Enum):\n    \"\"\"Tipos de token dispon√≠veis\"\"\"\n    ACCESS = \"access\"\n    REFRESH = \"refresh\"\n    API_KEY = \"api_key\"\n\n\nclass AuthScope(str, Enum):\n    \"\"\"Escopos de autoriza√ß√£o\"\"\"\n    AGENTS_READ = \"agents:read\"\n    AGENTS_WRITE = \"agents:write\"\n    AGENTS_DELETE = \"agents:delete\"\n    WHATSAPP_READ = \"whatsapp:read\"\n    WHATSAPP_WRITE = \"whatsapp:write\"\n    WHATSAPP_ADMIN = \"whatsapp:admin\"\n    LOGS_READ = \"logs:read\"\n    SYSTEM_ADMIN = \"system:admin\"\n\n\n@dataclass\nclass User:\n    \"\"\"Modelo de usu√°rio do sistema\"\"\"\n    id: str\n    username: str\n    email: str\n    role: UserRole\n    scopes: List[AuthScope] = field(default_factory=list)\n    is_active: bool = True\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    last_login: Optional[datetime] = None\n    failed_login_attempts: int = 0\n    locked_until: Optional[datetime] = None\n    \n    def is_locked(self) -> bool:\n        \"\"\"Verifica se a conta est√° bloqueada\"\"\"\n        if self.locked_until and datetime.now(timezone.utc) < self.locked_until:\n            return True\n        return False\n    \n    def has_scope(self, scope: AuthScope) -> bool:\n        \"\"\"Verifica se o usu√°rio tem um escopo espec√≠fico\"\"\"\n        return scope in self.scopes\n    \n    def has_any_scope(self, scopes: List[AuthScope]) -> bool:\n        \"\"\"Verifica se o usu√°rio tem pelo menos um dos escopos\"\"\"\n        return any(scope in self.scopes for scope in scopes)\n\n\n@dataclass\nclass APIKey:\n    \"\"\"Modelo de API Key\"\"\"\n    id: str\n    name: str\n    key_hash: str\n    user_id: str\n    scopes: List[AuthScope]\n    is_active: bool = True\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    expires_at: Optional[datetime] = None\n    last_used: Optional[datetime] = None\n    usage_count: int = 0\n    rate_limit: int = 1000  # requests per hour\n    \n    def is_expired(self) -> bool:\n        \"\"\"Verifica se a API key est√° expirada\"\"\"\n        if self.expires_at and datetime.now(timezone.utc) > self.expires_at:\n            return True\n        return False\n\n\nclass TokenPayload(BaseModel):\n    \"\"\"Payload do JWT token\"\"\"\n    sub: str = Field(..., description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    role: UserRole = Field(..., description=\"User role\")\n    scopes: List[AuthScope] = Field(default_factory=list, description=\"User scopes\")\n    token_type: TokenType = Field(..., description=\"Token type\")\n    iat: int = Field(..., description=\"Issued at\")\n    exp: int = Field(..., description=\"Expires at\")\n    jti: str = Field(..., description=\"JWT ID\")\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Exce√ß√£o para erros de autentica√ß√£o\"\"\"\n    pass\n\n\nclass AuthorizationError(Exception):\n    \"\"\"Exce√ß√£o para erros de autoriza√ß√£o\"\"\"\n    pass\n\n\nclass RateLimitExceeded(Exception):\n    \"\"\"Exce√ß√£o para rate limit excedido\"\"\"\n    pass\n\n\nclass JWTAuthenticator:\n    \"\"\"\n    Sistema de autentica√ß√£o JWT com funcionalidades avan√ßadas de seguran√ßa\n    \"\"\"\n    \n    def __init__(self, secret_key: str, redis_url: Optional[str] = None):\n        self.secret_key = secret_key\n        self.algorithm = \"HS256\"\n        self.access_token_expire = timedelta(hours=1)\n        self.refresh_token_expire = timedelta(days=7)\n        \n        # Redis para cache e blacklist\n        self.redis_client = None\n        if redis_url:\n            self.redis_client = redis.from_url(redis_url)\n        \n        # Cache em mem√≥ria para fallback\n        self._users_cache: Dict[str, User] = {}\n        self._api_keys_cache: Dict[str, APIKey] = {}\n        self._blacklisted_tokens: set = set()\n        self._rate_limit_cache: Dict[str, List[datetime]] = defaultdict(list)\n        \n        # Configura√ß√µes de seguran√ßa\n        self.max_failed_attempts = 5\n        self.lockout_duration = timedelta(minutes=30)\n        self.rate_limit_window = timedelta(hours=1)\n        \n        logger.info(\"üîê JWTAuthenticator inicializado\")\n    \n    async def create_user(\n        self,\n        username: str,\n        email: str,\n        role: UserRole,\n        scopes: Optional[List[AuthScope]] = None\n    ) -> User:\n        \"\"\"Cria um novo usu√°rio\"\"\"\n        user_id = self._generate_id()\n        \n        if scopes is None:\n            scopes = self._get_default_scopes(role)\n        \n        user = User(\n            id=user_id,\n            username=username,\n            email=email,\n            role=role,\n            scopes=scopes\n        )\n        \n        self._users_cache[user_id] = user\n        \n        if self.redis_client:\n            await self.redis_client.hset(\n                f\"user:{user_id}\",\n                mapping={\n                    \"username\": username,\n                    \"email\": email,\n                    \"role\": role.value,\n                    \"scopes\": \",\".join([s.value for s in scopes]),\n                    \"is_active\": \"true\",\n                    \"created_at\": user.created_at.isoformat()\n                }\n            )\n        \n        logger.info(f\"üë§ Usu√°rio criado: {username} ({role.value})\")\n        return user\n    \n    async def create_api_key(\n        self,\n        user_id: str,\n        name: str,\n        scopes: List[AuthScope],\n        expires_in_days: Optional[int] = None,\n        rate_limit: int = 1000\n    ) -> tuple[str, APIKey]:\n        \"\"\"Cria uma nova API key\"\"\"\n        api_key_id = self._generate_id()\n        raw_key = self._generate_api_key()\n        key_hash = self._hash_api_key(raw_key)\n        \n        expires_at = None\n        if expires_in_days:\n            expires_at = datetime.now(timezone.utc) + timedelta(days=expires_in_days)\n        \n        api_key = APIKey(\n            id=api_key_id,\n            name=name,\n            key_hash=key_hash,\n            user_id=user_id,\n            scopes=scopes,\n            expires_at=expires_at,\n            rate_limit=rate_limit\n        )\n        \n        self._api_keys_cache[api_key_id] = api_key\n        \n        if self.redis_client:\n            await self.redis_client.hset(\n                f\"api_key:{api_key_id}\",\n                mapping={\n                    \"name\": name,\n                    \"key_hash\": key_hash,\n                    \"user_id\": user_id,\n                    \"scopes\": \",\".join([s.value for s in scopes]),\n                    \"is_active\": \"true\",\n                    \"created_at\": api_key.created_at.isoformat(),\n                    \"expires_at\": expires_at.isoformat() if expires_at else \"\",\n                    \"rate_limit\": str(rate_limit)\n                }\n            )\n        \n        logger.info(f\"üîë API Key criada: {name} para usu√°rio {user_id}\")\n        return raw_key, api_key\n    \n    async def generate_tokens(self, user: User) -> Dict[str, str]:\n        \"\"\"Gera access e refresh tokens para um usu√°rio\"\"\"\n        now = datetime.now(timezone.utc)\n        \n        # Access token\n        access_payload = TokenPayload(\n            sub=user.id,\n            username=user.username,\n            role=user.role,\n            scopes=user.scopes,\n            token_type=TokenType.ACCESS,\n            iat=int(now.timestamp()),\n            exp=int((now + self.access_token_expire).timestamp()),\n            jti=self._generate_id()\n        )\n        \n        # Refresh token\n        refresh_payload = TokenPayload(\n            sub=user.id,\n            username=user.username,\n            role=user.role,\n            scopes=user.scopes,\n            token_type=TokenType.REFRESH,\n            iat=int(now.timestamp()),\n            exp=int((now + self.refresh_token_expire).timestamp()),\n            jti=self._generate_id()\n        )\n        \n        access_token = jwt.encode(\n            access_payload.dict(),\n            self.secret_key,\n            algorithm=self.algorithm\n        )\n        \n        refresh_token = jwt.encode(\n            refresh_payload.dict(),\n            self.secret_key,\n            algorithm=self.algorithm\n        )\n        \n        # Atualiza √∫ltimo login\n        user.last_login = now\n        \n        return {\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n            \"token_type\": \"bearer\",\n            \"expires_in\": int(self.access_token_expire.total_seconds())\n        }\n    \n    async def verify_token(self, token: str) -> TokenPayload:\n        \"\"\"Verifica e decodifica um JWT token\"\"\"\n        try:\n            # Verifica se o token est√° na blacklist\n            if await self._is_token_blacklisted(token):\n                raise AuthenticationError(\"Token revogado\")\n            \n            # Decodifica o token\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm]\n            )\n            \n            token_payload = TokenPayload(**payload)\n            \n            # Verifica se o usu√°rio ainda existe e est√° ativo\n            user = await self.get_user(token_payload.sub)\n            if not user or not user.is_active:\n                raise AuthenticationError(\"Usu√°rio inv√°lido ou inativo\")\n            \n            return token_payload\n            \n        except jwt.ExpiredSignatureError:\n            raise AuthenticationError(\"Token expirado\")\n        except jwt.InvalidTokenError:\n            raise AuthenticationError(\"Token inv√°lido\")\n    \n    async def verify_api_key(self, api_key: str) -> tuple[User, APIKey]:\n        \"\"\"Verifica uma API key\"\"\"\n        key_hash = self._hash_api_key(api_key)\n        \n        # Busca a API key\n        api_key_obj = None\n        for cached_key in self._api_keys_cache.values():\n            if cached_key.key_hash == key_hash:\n                api_key_obj = cached_key\n                break\n        \n        if not api_key_obj:\n            raise AuthenticationError(\"API key inv√°lida\")\n        \n        if not api_key_obj.is_active or api_key_obj.is_expired():\n            raise AuthenticationError(\"API key inativa ou expirada\")\n        \n        # Verifica rate limit\n        if not await self._check_api_key_rate_limit(api_key_obj):\n            raise RateLimitExceeded(\"Rate limit excedido para API key\")\n        \n        # Busca o usu√°rio\n        user = await self.get_user(api_key_obj.user_id)\n        if not user or not user.is_active:\n            raise AuthenticationError(\"Usu√°rio da API key inv√°lido\")\n        \n        # Atualiza estat√≠sticas\n        api_key_obj.last_used = datetime.now(timezone.utc)\n        api_key_obj.usage_count += 1\n        \n        return user, api_key_obj\n    \n    async def revoke_token(self, token: str) -> bool:\n        \"\"\"Revoga um token (adiciona √† blacklist)\"\"\"\n        try:\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm],\n                options={\"verify_exp\": False}  # N√£o verifica expira√ß√£o\n            )\n            \n            jti = payload.get(\"jti\")\n            if jti:\n                self._blacklisted_tokens.add(jti)\n                \n                if self.redis_client:\n                    await self.redis_client.sadd(\"blacklisted_tokens\", jti)\n                    # Define TTL baseado na expira√ß√£o do token\n                    exp = payload.get(\"exp\")\n                    if exp:\n                        ttl = exp - int(datetime.now(timezone.utc).timestamp())\n                        if ttl > 0:\n                            await self.redis_client.expire(\"blacklisted_tokens\", ttl)\n                \n                logger.info(f\"üö´ Token revogado: {jti}\")\n                return True\n                \n        except jwt.InvalidTokenError:\n            pass\n        \n        return False\n    \n    async def revoke_api_key(self, api_key_id: str) -> bool:\n        \"\"\"Revoga uma API key\"\"\"\n        if api_key_id in self._api_keys_cache:\n            self._api_keys_cache[api_key_id].is_active = False\n            \n            if self.redis_client:\n                await self.redis_client.hset(\n                    f\"api_key:{api_key_id}\",\n                    \"is_active\",\n                    \"false\"\n                )\n            \n            logger.info(f\"üö´ API Key revogada: {api_key_id}\")\n            return True\n        \n        return False\n    \n    async def get_user(self, user_id: str) -> Optional[User]:\n        \"\"\"Busca um usu√°rio por ID\"\"\"\n        if user_id in self._users_cache:\n            return self._users_cache[user_id]\n        \n        if self.redis_client:\n            user_data = await self.redis_client.hgetall(f\"user:{user_id}\")\n            if user_data:\n                scopes = [AuthScope(s) for s in user_data[\"scopes\"].split(\",\") if s]\n                user = User(\n                    id=user_id,\n                    username=user_data[\"username\"],\n                    email=user_data[\"email\"],\n                    role=UserRole(user_data[\"role\"]),\n                    scopes=scopes,\n                    is_active=user_data[\"is_active\"] == \"true\",\n                    created_at=datetime.fromisoformat(user_data[\"created_at\"])\n                )\n                self._users_cache[user_id] = user\n                return user\n        \n        return None\n    \n    async def check_permission(\n        self,\n        user: User,\n        required_scopes: List[AuthScope],\n        require_all: bool = False\n    ) -> bool:\n        \"\"\"Verifica se o usu√°rio tem as permiss√µes necess√°rias\"\"\"\n        if user.role == UserRole.ADMIN:\n            return True\n        \n        if require_all:\n            return all(user.has_scope(scope) for scope in required_scopes)\n        else:\n            return user.has_any_scope(required_scopes)\n    \n    async def rate_limit_check(self, identifier: str, limit: int = 100) -> bool:\n        \"\"\"Verifica rate limit para um identificador\"\"\"\n        now = datetime.now(timezone.utc)\n        window_start = now - self.rate_limit_window\n        \n        # Remove entradas antigas\n        self._rate_limit_cache[identifier] = [\n            timestamp for timestamp in self._rate_limit_cache[identifier]\n            if timestamp > window_start\n        ]\n        \n        # Verifica se excedeu o limite\n        if len(self._rate_limit_cache[identifier]) >= limit:\n            return False\n        \n        # Adiciona nova entrada\n        self._rate_limit_cache[identifier].append(now)\n        return True\n    \n    def _generate_id(self) -> str:\n        \"\"\"Gera um ID √∫nico\"\"\"\n        return secrets.token_urlsafe(16)\n    \n    def _generate_api_key(self) -> str:\n        \"\"\"Gera uma API key\"\"\"\n        return f\"agno_{secrets.token_urlsafe(32)}\"\n    \n    def _hash_api_key(self, api_key: str) -> str:\n        \"\"\"Gera hash de uma API key\"\"\"\n        return hashlib.sha256(api_key.encode()).hexdigest()\n    \n    def _get_default_scopes(self, role: UserRole) -> List[AuthScope]:\n        \"\"\"Retorna escopos padr√£o para um role\"\"\"\n        scope_mapping = {\n            UserRole.ADMIN: list(AuthScope),\n            UserRole.DEVELOPER: [\n                AuthScope.AGENTS_READ,\n                AuthScope.AGENTS_WRITE,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.WHATSAPP_WRITE,\n                AuthScope.LOGS_READ\n            ],\n            UserRole.AGENT_MANAGER: [\n                AuthScope.AGENTS_READ,\n                AuthScope.AGENTS_WRITE,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.WHATSAPP_WRITE\n            ],\n            UserRole.API_USER: [\n                AuthScope.AGENTS_READ,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.WHATSAPP_WRITE\n            ],\n            UserRole.READONLY: [\n                AuthScope.AGENTS_READ,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.LOGS_READ\n            ]\n        }\n        return scope_mapping.get(role, [])\n    \n    async def _is_token_blacklisted(self, token: str) -> bool:\n        \"\"\"Verifica se um token est√° na blacklist\"\"\"\n        try:\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm],\n                options={\"verify_exp\": False}\n            )\n            jti = payload.get(\"jti\")\n            \n            if jti in self._blacklisted_tokens:\n                return True\n            \n            if self.redis_client:\n                is_blacklisted = await self.redis_client.sismember(\"blacklisted_tokens\", jti)\n                if is_blacklisted:\n                    self._blacklisted_tokens.add(jti)\n                    return True\n            \n        except jwt.InvalidTokenError:\n            pass\n        \n        return False\n    \n    async def _check_api_key_rate_limit(self, api_key: APIKey) -> bool:\n        \"\"\"Verifica rate limit de uma API key\"\"\"\n        return await self.rate_limit_check(\n            f\"api_key:{api_key.id}\",\n            api_key.rate_limit\n        )\n\n\nclass SecureHTTPBearer(HTTPBearer):\n    \"\"\"\n    HTTPBearer customizado com funcionalidades de seguran√ßa\n    \"\"\"\n    \n    def __init__(self, authenticator: JWTAuthenticator, auto_error: bool = True):\n        super().__init__(auto_error=auto_error)\n        self.authenticator = authenticator\n    \n    async def __call__(self, request: Request) -> Optional[HTTPAuthorizationCredentials]:\n        # Verifica rate limit por IP\n        client_ip = request.client.host\n        if not await self.authenticator.rate_limit_check(f\"ip:{client_ip}\", 1000):\n            raise HTTPException(\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n                detail=\"Rate limit excedido\"\n            )\n        \n        return await super().__call__(request)\n\n\n# Fun√ß√µes utilit√°rias para depend√™ncias FastAPI\n\ndef create_auth_dependency(authenticator: JWTAuthenticator, required_scopes: List[AuthScope] = None):\n    \"\"\"Cria uma depend√™ncia de autentica√ß√£o para FastAPI\"\"\"\n    \n    async def auth_dependency(\n        request: Request,\n        credentials: Optional[HTTPAuthorizationCredentials] = Depends(SecureHTTPBearer(authenticator, auto_error=False))\n    ) -> User:\n        # Tenta autentica√ß√£o por API key primeiro\n        api_key = request.headers.get(\"X-API-Key\")\n        if api_key:\n            try:\n                user, api_key_obj = await authenticator.verify_api_key(api_key)\n                \n                # Verifica escopos se especificados\n                if required_scopes:\n                    if not await authenticator.check_permission(user, required_scopes):\n                        raise HTTPException(\n                            status_code=status.HTTP_403_FORBIDDEN,\n                            detail=\"Permiss√µes insuficientes\"\n                        )\n                \n                return user\n                \n            except (AuthenticationError, RateLimitExceeded) as e:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=str(e)\n                )\n        \n        # Autentica√ß√£o por JWT\n        if not credentials:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Token de autentica√ß√£o necess√°rio\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        try:\n            token_payload = await authenticator.verify_token(credentials.credentials)\n            user = await authenticator.get_user(token_payload.sub)\n            \n            if not user:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Usu√°rio n√£o encontrado\"\n                )\n            \n            # Verifica escopos se especificados\n            if required_scopes:\n                if not await authenticator.check_permission(user, required_scopes):\n                    raise HTTPException(\n                        status_code=status.HTTP_403_FORBIDDEN,\n                        detail=\"Permiss√µes insuficientes\"\n                    )\n            \n            return user\n            \n        except AuthenticationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=str(e),\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n    \n    return auth_dependency\n\n\ndef require_scopes(*scopes: AuthScope):\n    \"\"\"Decorator para exigir escopos espec√≠ficos\"\"\"\n    def decorator(authenticator: JWTAuthenticator):\n        return create_auth_dependency(authenticator, list(scopes))\n    return decorator\n"}}