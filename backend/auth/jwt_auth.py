"""\nSistema de Autenticação JWT para Evolution API\n\nImplementa autenticação robusta com JWT tokens, API keys e controle de acesso\nbaseado em roles. Inclui funcionalidades de segurança como rate limiting,\nblacklist de tokens e validação de integridade.\n\nFuncionalidades:\n- Geração e validação de JWT tokens\n- Sistema de API keys com scopes\n- Rate limiting por usuário/IP\n- Blacklist de tokens revogados\n- Controle de acesso baseado em roles\n- Auditoria de autenticação\n\nAutor: AgnoMaster - Evolution API Security Expert\nData: 2025-01-24\n"""\n\nimport jwt\nimport secrets\nimport hashlib\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, List, Optional, Any, Union\nfrom enum import Enum\nfrom dataclasses import dataclass, field\nimport asyncio\nfrom collections import defaultdict\n\nfrom fastapi import HTTPException, status, Request\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, Field\nfrom loguru import logger\nimport redis.asyncio as redis\n\n\nclass UserRole(str, Enum):\n    \"\"\"Roles de usuário no sistema\"\"\"\n    ADMIN = \"admin\"\n    DEVELOPER = \"developer\"\n    AGENT_MANAGER = \"agent_manager\"\n    API_USER = \"api_user\"\n    READONLY = \"readonly\"\n\n\nclass TokenType(str, Enum):\n    \"\"\"Tipos de token disponíveis\"\"\"\n    ACCESS = \"access\"\n    REFRESH = \"refresh\"\n    API_KEY = \"api_key\"\n\n\nclass AuthScope(str, Enum):\n    \"\"\"Escopos de autorização\"\"\"\n    AGENTS_READ = \"agents:read\"\n    AGENTS_WRITE = \"agents:write\"\n    AGENTS_DELETE = \"agents:delete\"\n    WHATSAPP_READ = \"whatsapp:read\"\n    WHATSAPP_WRITE = \"whatsapp:write\"\n    WHATSAPP_ADMIN = \"whatsapp:admin\"\n    LOGS_READ = \"logs:read\"\n    SYSTEM_ADMIN = \"system:admin\"\n\n\n@dataclass\nclass User:\n    \"\"\"Modelo de usuário do sistema\"\"\"\n    id: str\n    username: str\n    email: str\n    role: UserRole\n    scopes: List[AuthScope] = field(default_factory=list)\n    is_active: bool = True\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    last_login: Optional[datetime] = None\n    failed_login_attempts: int = 0\n    locked_until: Optional[datetime] = None\n    \n    def is_locked(self) -> bool:\n        \"\"\"Verifica se a conta está bloqueada\"\"\"\n        if self.locked_until and datetime.now(timezone.utc) < self.locked_until:\n            return True\n        return False\n    \n    def has_scope(self, scope: AuthScope) -> bool:\n        \"\"\"Verifica se o usuário tem um escopo específico\"\"\"\n        return scope in self.scopes\n    \n    def has_any_scope(self, scopes: List[AuthScope]) -> bool:\n        \"\"\"Verifica se o usuário tem pelo menos um dos escopos\"\"\"\n        return any(scope in self.scopes for scope in scopes)\n\n\n@dataclass\nclass APIKey:\n    \"\"\"Modelo de API Key\"\"\"\n    id: str\n    name: str\n    key_hash: str\n    user_id: str\n    scopes: List[AuthScope]\n    is_active: bool = True\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    expires_at: Optional[datetime] = None\n    last_used: Optional[datetime] = None\n    usage_count: int = 0\n    rate_limit: int = 1000  # requests per hour\n    \n    def is_expired(self) -> bool:\n        \"\"\"Verifica se a API key está expirada\"\"\"\n        if self.expires_at and datetime.now(timezone.utc) > self.expires_at:\n            return True\n        return False\n\n\nclass TokenPayload(BaseModel):\n    \"\"\"Payload do JWT token\"\"\"\n    sub: str = Field(..., description=\"User ID\")\n    username: str = Field(..., description=\"Username\")\n    role: UserRole = Field(..., description=\"User role\")\n    scopes: List[AuthScope] = Field(default_factory=list, description=\"User scopes\")\n    token_type: TokenType = Field(..., description=\"Token type\")\n    iat: int = Field(..., description=\"Issued at\")\n    exp: int = Field(..., description=\"Expires at\")\n    jti: str = Field(..., description=\"JWT ID\")\n\n\nclass AuthenticationError(Exception):\n    \"\"\"Exceção para erros de autenticação\"\"\"\n    pass\n\n\nclass AuthorizationError(Exception):\n    \"\"\"Exceção para erros de autorização\"\"\"\n    pass\n\n\nclass RateLimitExceeded(Exception):\n    \"\"\"Exceção para rate limit excedido\"\"\"\n    pass\n\n\nclass JWTAuthenticator:\n    \"\"\"\n    Sistema de autenticação JWT com funcionalidades avançadas de segurança\n    \"\"\"\n    \n    def __init__(self, secret_key: str, redis_url: Optional[str] = None):\n        self.secret_key = secret_key\n        self.algorithm = \"HS256\"\n        self.access_token_expire = timedelta(hours=1)\n        self.refresh_token_expire = timedelta(days=7)\n        \n        # Redis para cache e blacklist\n        self.redis_client = None\n        if redis_url:\n            self.redis_client = redis.from_url(redis_url)\n        \n        # Cache em memória para fallback\n        self._users_cache: Dict[str, User] = {}\n        self._api_keys_cache: Dict[str, APIKey] = {}\n        self._blacklisted_tokens: set = set()\n        self._rate_limit_cache: Dict[str, List[datetime]] = defaultdict(list)\n        \n        # Configurações de segurança\n        self.max_failed_attempts = 5\n        self.lockout_duration = timedelta(minutes=30)\n        self.rate_limit_window = timedelta(hours=1)\n        \n        logger.info(\"🔐 JWTAuthenticator inicializado\")\n    \n    async def create_user(\n        self,\n        username: str,\n        email: str,\n        role: UserRole,\n        scopes: Optional[List[AuthScope]] = None\n    ) -> User:\n        \"\"\"Cria um novo usuário\"\"\"\n        user_id = self._generate_id()\n        \n        if scopes is None:\n            scopes = self._get_default_scopes(role)\n        \n        user = User(\n            id=user_id,\n            username=username,\n            email=email,\n            role=role,\n            scopes=scopes\n        )\n        \n        self._users_cache[user_id] = user\n        \n        if self.redis_client:\n            await self.redis_client.hset(\n                f\"user:{user_id}\",\n                mapping={\n                    \"username\": username,\n                    \"email\": email,\n                    \"role\": role.value,\n                    \"scopes\": \",\".join([s.value for s in scopes]),\n                    \"is_active\": \"true\",\n                    \"created_at\": user.created_at.isoformat()\n                }\n            )\n        \n        logger.info(f\"👤 Usuário criado: {username} ({role.value})\")\n        return user\n    \n    async def create_api_key(\n        self,\n        user_id: str,\n        name: str,\n        scopes: List[AuthScope],\n        expires_in_days: Optional[int] = None,\n        rate_limit: int = 1000\n    ) -> tuple[str, APIKey]:\n        \"\"\"Cria uma nova API key\"\"\"\n        api_key_id = self._generate_id()\n        raw_key = self._generate_api_key()\n        key_hash = self._hash_api_key(raw_key)\n        \n        expires_at = None\n        if expires_in_days:\n            expires_at = datetime.now(timezone.utc) + timedelta(days=expires_in_days)\n        \n        api_key = APIKey(\n            id=api_key_id,\n            name=name,\n            key_hash=key_hash,\n            user_id=user_id,\n            scopes=scopes,\n            expires_at=expires_at,\n            rate_limit=rate_limit\n        )\n        \n        self._api_keys_cache[api_key_id] = api_key\n        \n        if self.redis_client:\n            await self.redis_client.hset(\n                f\"api_key:{api_key_id}\",\n                mapping={\n                    \"name\": name,\n                    \"key_hash\": key_hash,\n                    \"user_id\": user_id,\n                    \"scopes\": \",\".join([s.value for s in scopes]),\n                    \"is_active\": \"true\",\n                    \"created_at\": api_key.created_at.isoformat(),\n                    \"expires_at\": expires_at.isoformat() if expires_at else \"\",\n                    \"rate_limit\": str(rate_limit)\n                }\n            )\n        \n        logger.info(f\"🔑 API Key criada: {name} para usuário {user_id}\")\n        return raw_key, api_key\n    \n    async def generate_tokens(self, user: User) -> Dict[str, str]:\n        \"\"\"Gera access e refresh tokens para um usuário\"\"\"\n        now = datetime.now(timezone.utc)\n        \n        # Access token\n        access_payload = TokenPayload(\n            sub=user.id,\n            username=user.username,\n            role=user.role,\n            scopes=user.scopes,\n            token_type=TokenType.ACCESS,\n            iat=int(now.timestamp()),\n            exp=int((now + self.access_token_expire).timestamp()),\n            jti=self._generate_id()\n        )\n        \n        # Refresh token\n        refresh_payload = TokenPayload(\n            sub=user.id,\n            username=user.username,\n            role=user.role,\n            scopes=user.scopes,\n            token_type=TokenType.REFRESH,\n            iat=int(now.timestamp()),\n            exp=int((now + self.refresh_token_expire).timestamp()),\n            jti=self._generate_id()\n        )\n        \n        access_token = jwt.encode(\n            access_payload.dict(),\n            self.secret_key,\n            algorithm=self.algorithm\n        )\n        \n        refresh_token = jwt.encode(\n            refresh_payload.dict(),\n            self.secret_key,\n            algorithm=self.algorithm\n        )\n        \n        # Atualiza último login\n        user.last_login = now\n        \n        return {\n            \"access_token\": access_token,\n            \"refresh_token\": refresh_token,\n            \"token_type\": \"bearer\",\n            \"expires_in\": int(self.access_token_expire.total_seconds())\n        }\n    \n    async def verify_token(self, token: str) -> TokenPayload:\n        \"\"\"Verifica e decodifica um JWT token\"\"\"\n        try:\n            # Verifica se o token está na blacklist\n            if await self._is_token_blacklisted(token):\n                raise AuthenticationError(\"Token revogado\")\n            \n            # Decodifica o token\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm]\n            )\n            \n            token_payload = TokenPayload(**payload)\n            \n            # Verifica se o usuário ainda existe e está ativo\n            user = await self.get_user(token_payload.sub)\n            if not user or not user.is_active:\n                raise AuthenticationError(\"Usuário inválido ou inativo\")\n            \n            return token_payload\n            \n        except jwt.ExpiredSignatureError:\n            raise AuthenticationError(\"Token expirado\")\n        except jwt.InvalidTokenError:\n            raise AuthenticationError(\"Token inválido\")\n    \n    async def verify_api_key(self, api_key: str) -> tuple[User, APIKey]:\n        \"\"\"Verifica uma API key\"\"\"\n        key_hash = self._hash_api_key(api_key)\n        \n        # Busca a API key\n        api_key_obj = None\n        for cached_key in self._api_keys_cache.values():\n            if cached_key.key_hash == key_hash:\n                api_key_obj = cached_key\n                break\n        \n        if not api_key_obj:\n            raise AuthenticationError(\"API key inválida\")\n        \n        if not api_key_obj.is_active or api_key_obj.is_expired():\n            raise AuthenticationError(\"API key inativa ou expirada\")\n        \n        # Verifica rate limit\n        if not await self._check_api_key_rate_limit(api_key_obj):\n            raise RateLimitExceeded(\"Rate limit excedido para API key\")\n        \n        # Busca o usuário\n        user = await self.get_user(api_key_obj.user_id)\n        if not user or not user.is_active:\n            raise AuthenticationError(\"Usuário da API key inválido\")\n        \n        # Atualiza estatísticas\n        api_key_obj.last_used = datetime.now(timezone.utc)\n        api_key_obj.usage_count += 1\n        \n        return user, api_key_obj\n    \n    async def revoke_token(self, token: str) -> bool:\n        \"\"\"Revoga um token (adiciona à blacklist)\"\"\"\n        try:\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm],\n                options={\"verify_exp\": False}  # Não verifica expiração\n            )\n            \n            jti = payload.get(\"jti\")\n            if jti:\n                self._blacklisted_tokens.add(jti)\n                \n                if self.redis_client:\n                    await self.redis_client.sadd(\"blacklisted_tokens\", jti)\n                    # Define TTL baseado na expiração do token\n                    exp = payload.get(\"exp\")\n                    if exp:\n                        ttl = exp - int(datetime.now(timezone.utc).timestamp())\n                        if ttl > 0:\n                            await self.redis_client.expire(\"blacklisted_tokens\", ttl)\n                \n                logger.info(f\"🚫 Token revogado: {jti}\")\n                return True\n                \n        except jwt.InvalidTokenError:\n            pass\n        \n        return False\n    \n    async def revoke_api_key(self, api_key_id: str) -> bool:\n        \"\"\"Revoga uma API key\"\"\"\n        if api_key_id in self._api_keys_cache:\n            self._api_keys_cache[api_key_id].is_active = False\n            \n            if self.redis_client:\n                await self.redis_client.hset(\n                    f\"api_key:{api_key_id}\",\n                    \"is_active\",\n                    \"false\"\n                )\n            \n            logger.info(f\"🚫 API Key revogada: {api_key_id}\")\n            return True\n        \n        return False\n    \n    async def get_user(self, user_id: str) -> Optional[User]:\n        \"\"\"Busca um usuário por ID\"\"\"\n        if user_id in self._users_cache:\n            return self._users_cache[user_id]\n        \n        if self.redis_client:\n            user_data = await self.redis_client.hgetall(f\"user:{user_id}\")\n            if user_data:\n                scopes = [AuthScope(s) for s in user_data[\"scopes\"].split(\",\") if s]\n                user = User(\n                    id=user_id,\n                    username=user_data[\"username\"],\n                    email=user_data[\"email\"],\n                    role=UserRole(user_data[\"role\"]),\n                    scopes=scopes,\n                    is_active=user_data[\"is_active\"] == \"true\",\n                    created_at=datetime.fromisoformat(user_data[\"created_at\"])\n                )\n                self._users_cache[user_id] = user\n                return user\n        \n        return None\n    \n    async def check_permission(\n        self,\n        user: User,\n        required_scopes: List[AuthScope],\n        require_all: bool = False\n    ) -> bool:\n        \"\"\"Verifica se o usuário tem as permissões necessárias\"\"\"\n        if user.role == UserRole.ADMIN:\n            return True\n        \n        if require_all:\n            return all(user.has_scope(scope) for scope in required_scopes)\n        else:\n            return user.has_any_scope(required_scopes)\n    \n    async def rate_limit_check(self, identifier: str, limit: int = 100) -> bool:\n        \"\"\"Verifica rate limit para um identificador\"\"\"\n        now = datetime.now(timezone.utc)\n        window_start = now - self.rate_limit_window\n        \n        # Remove entradas antigas\n        self._rate_limit_cache[identifier] = [\n            timestamp for timestamp in self._rate_limit_cache[identifier]\n            if timestamp > window_start\n        ]\n        \n        # Verifica se excedeu o limite\n        if len(self._rate_limit_cache[identifier]) >= limit:\n            return False\n        \n        # Adiciona nova entrada\n        self._rate_limit_cache[identifier].append(now)\n        return True\n    \n    def _generate_id(self) -> str:\n        \"\"\"Gera um ID único\"\"\"\n        return secrets.token_urlsafe(16)\n    \n    def _generate_api_key(self) -> str:\n        \"\"\"Gera uma API key\"\"\"\n        return f\"agno_{secrets.token_urlsafe(32)}\"\n    \n    def _hash_api_key(self, api_key: str) -> str:\n        \"\"\"Gera hash de uma API key\"\"\"\n        return hashlib.sha256(api_key.encode()).hexdigest()\n    \n    def _get_default_scopes(self, role: UserRole) -> List[AuthScope]:\n        \"\"\"Retorna escopos padrão para um role\"\"\"\n        scope_mapping = {\n            UserRole.ADMIN: list(AuthScope),\n            UserRole.DEVELOPER: [\n                AuthScope.AGENTS_READ,\n                AuthScope.AGENTS_WRITE,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.WHATSAPP_WRITE,\n                AuthScope.LOGS_READ\n            ],\n            UserRole.AGENT_MANAGER: [\n                AuthScope.AGENTS_READ,\n                AuthScope.AGENTS_WRITE,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.WHATSAPP_WRITE\n            ],\n            UserRole.API_USER: [\n                AuthScope.AGENTS_READ,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.WHATSAPP_WRITE\n            ],\n            UserRole.READONLY: [\n                AuthScope.AGENTS_READ,\n                AuthScope.WHATSAPP_READ,\n                AuthScope.LOGS_READ\n            ]\n        }\n        return scope_mapping.get(role, [])\n    \n    async def _is_token_blacklisted(self, token: str) -> bool:\n        \"\"\"Verifica se um token está na blacklist\"\"\"\n        try:\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm],\n                options={\"verify_exp\": False}\n            )\n            jti = payload.get(\"jti\")\n            \n            if jti in self._blacklisted_tokens:\n                return True\n            \n            if self.redis_client:\n                is_blacklisted = await self.redis_client.sismember(\"blacklisted_tokens\", jti)\n                if is_blacklisted:\n                    self._blacklisted_tokens.add(jti)\n                    return True\n            \n        except jwt.InvalidTokenError:\n            pass\n        \n        return False\n    \n    async def _check_api_key_rate_limit(self, api_key: APIKey) -> bool:\n        \"\"\"Verifica rate limit de uma API key\"\"\"\n        return await self.rate_limit_check(\n            f\"api_key:{api_key.id}\",\n            api_key.rate_limit\n        )\n\n\nclass SecureHTTPBearer(HTTPBearer):\n    \"\"\"\n    HTTPBearer customizado com funcionalidades de segurança\n    \"\"\"\n    \n    def __init__(self, authenticator: JWTAuthenticator, auto_error: bool = True):\n        super().__init__(auto_error=auto_error)\n        self.authenticator = authenticator\n    \n    async def __call__(self, request: Request) -> Optional[HTTPAuthorizationCredentials]:\n        # Verifica rate limit por IP\n        client_ip = request.client.host\n        if not await self.authenticator.rate_limit_check(f\"ip:{client_ip}\", 1000):\n            raise HTTPException(\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n                detail=\"Rate limit excedido\"\n            )\n        \n        return await super().__call__(request)\n\n\n# Funções utilitárias para dependências FastAPI\n\ndef create_auth_dependency(authenticator: JWTAuthenticator, required_scopes: List[AuthScope] = None):\n    \"\"\"Cria uma dependência de autenticação para FastAPI\"\"\"\n    \n    async def auth_dependency(\n        request: Request,\n        credentials: Optional[HTTPAuthorizationCredentials] = Depends(SecureHTTPBearer(authenticator, auto_error=False))\n    ) -> User:\n        # Tenta autenticação por API key primeiro\n        api_key = request.headers.get(\"X-API-Key\")\n        if api_key:\n            try:\n                user, api_key_obj = await authenticator.verify_api_key(api_key)\n                \n                # Verifica escopos se especificados\n                if required_scopes:\n                    if not await authenticator.check_permission(user, required_scopes):\n                        raise HTTPException(\n                            status_code=status.HTTP_403_FORBIDDEN,\n                            detail=\"Permissões insuficientes\"\n                        )\n                \n                return user\n                \n            except (AuthenticationError, RateLimitExceeded) as e:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=str(e)\n                )\n        \n        # Autenticação por JWT\n        if not credentials:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Token de autenticação necessário\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        try:\n            token_payload = await authenticator.verify_token(credentials.credentials)\n            user = await authenticator.get_user(token_payload.sub)\n            \n            if not user:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Usuário não encontrado\"\n                )\n            \n            # Verifica escopos se especificados\n            if required_scopes:\n                if not await authenticator.check_permission(user, required_scopes):\n                    raise HTTPException(\n                        status_code=status.HTTP_403_FORBIDDEN,\n                        detail=\"Permissões insuficientes\"\n                    )\n            \n            return user\n            \n        except AuthenticationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=str(e),\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n    \n    return auth_dependency\n\n\ndef require_scopes(*scopes: AuthScope):\n    \"\"\"Decorator para exigir escopos específicos\"\"\"\n    def decorator(authenticator: JWTAuthenticator):\n        return create_auth_dependency(authenticator, list(scopes))\n    return decorator\n"}}