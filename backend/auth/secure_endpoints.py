"""\nSistema de Endpoints Seguros para Evolution API\n\nImplementa:\n- Valida√ß√£o avan√ßada de dados\n- Sanitiza√ß√£o de inputs\n- Controle de acesso granular\n- Valida√ß√£o de schemas\n- Prote√ß√£o contra ataques\n- Rate limiting por endpoint\n\nAutor: AgnoMaster - Evolution API Security Expert\nData: 2025-01-24\n"""\n\nimport re\nimport json\nimport hashlib\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional, Any, Callable, Union, Type\nfrom functools import wraps\nfrom enum import Enum\n\nfrom fastapi import Request, HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, ValidationError, validator\nfrom loguru import logger\n\nfrom .jwt_auth import JWTAuthenticator, User, AuthenticationError\nfrom .security_config import EvolutionSecuritySettings\n\n\nclass AccessLevel(str, Enum):\n    \"\"\"N√≠veis de acesso para endpoints\"\"\"\n    PUBLIC = \"public\"\n    AUTHENTICATED = \"authenticated\"\n    ADMIN = \"admin\"\n    SYSTEM = \"system\"\n\n\nclass EndpointScope(str, Enum):\n    \"\"\"Escopos de acesso para endpoints\"\"\"\n    READ = \"read\"\n    WRITE = \"write\"\n    DELETE = \"delete\"\n    ADMIN = \"admin\"\n    WEBHOOK = \"webhook\"\n    AGENT_CREATE = \"agent:create\"\n    AGENT_MANAGE = \"agent:manage\"\n    INSTANCE_CREATE = \"instance:create\"\n    INSTANCE_MANAGE = \"instance:manage\"\n    MESSAGE_SEND = \"message:send\"\n    MESSAGE_READ = \"message:read\"\n\n\nclass InputSanitizer:\n    \"\"\"\n    Sanitizador de inputs para prevenir ataques\n    \"\"\"\n    \n    @staticmethod\n    def sanitize_string(value: str, max_length: int = 1000) -> str:\n        \"\"\"Sanitiza uma string\"\"\"\n        if not isinstance(value, str):\n            raise ValueError(\"Valor deve ser uma string\")\n        \n        # Remove caracteres de controle\n        value = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', value)\n        \n        # Remove scripts maliciosos\n        value = re.sub(r'<script[^>]*>.*?</script>', '', value, flags=re.IGNORECASE | re.DOTALL)\n        \n        # Remove javascript: URLs\n        value = re.sub(r'javascript:', '', value, flags=re.IGNORECASE)\n        \n        # Remove on* event handlers\n        value = re.sub(r'\\bon\\w+\\s*=', '', value, flags=re.IGNORECASE)\n        \n        # Limita o tamanho\n        if len(value) > max_length:\n            value = value[:max_length]\n        \n        return value.strip()\n    \n    @staticmethod\n    def sanitize_phone(phone: str) -> str:\n        \"\"\"Sanitiza n√∫mero de telefone\"\"\"\n        # Remove tudo exceto d√≠gitos e +\n        phone = re.sub(r'[^0-9+]', '', phone)\n        \n        # Valida formato b√°sico\n        if not re.match(r'^\\+?[1-9]\\d{1,14}$', phone):\n            raise ValueError(\"Formato de telefone inv√°lido\")\n        \n        return phone\n    \n    @staticmethod\n    def sanitize_email(email: str) -> str:\n        \"\"\"Sanitiza email\"\"\"\n        email = email.lower().strip()\n        \n        # Valida√ß√£o b√°sica de email\n        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', email):\n            raise ValueError(\"Formato de email inv√°lido\")\n        \n        return email\n    \n    @staticmethod\n    def sanitize_filename(filename: str) -> str:\n        \"\"\"Sanitiza nome de arquivo\"\"\"\n        # Remove caracteres perigosos\n        filename = re.sub(r'[<>:\"/\\\\|?*]', '', filename)\n        \n        # Remove path traversal\n        filename = re.sub(r'\\.\\.[\\/\\\\]*', '', filename)\n        \n        # Remove espa√ßos extras\n        filename = re.sub(r'\\s+', ' ', filename).strip()\n        \n        if not filename:\n            raise ValueError(\"Nome de arquivo inv√°lido\")\n        \n        return filename\n    \n    @staticmethod\n    def sanitize_json(data: Any) -> Any:\n        \"\"\"Sanitiza dados JSON recursivamente\"\"\"\n        if isinstance(data, dict):\n            return {\n                InputSanitizer.sanitize_string(str(k), 100): \n                InputSanitizer.sanitize_json(v)\n                for k, v in data.items()\n            }\n        elif isinstance(data, list):\n            return [InputSanitizer.sanitize_json(item) for item in data]\n        elif isinstance(data, str):\n            return InputSanitizer.sanitize_string(data)\n        else:\n            return data\n\n\nclass SecureValidator:\n    \"\"\"\n    Validador seguro para dados de entrada\n    \"\"\"\n    \n    @staticmethod\n    def validate_agent_name(name: str) -> str:\n        \"\"\"Valida nome de agente\"\"\"\n        name = InputSanitizer.sanitize_string(name, 100)\n        \n        if len(name) < 3:\n            raise ValueError(\"Nome do agente deve ter pelo menos 3 caracteres\")\n        \n        if not re.match(r'^[a-zA-Z0-9\\s_-]+$', name):\n            raise ValueError(\"Nome do agente cont√©m caracteres inv√°lidos\")\n        \n        return name\n    \n    @staticmethod\n    def validate_instance_name(name: str) -> str:\n        \"\"\"Valida nome de inst√¢ncia\"\"\"\n        name = InputSanitizer.sanitize_string(name, 50)\n        \n        if len(name) < 3:\n            raise ValueError(\"Nome da inst√¢ncia deve ter pelo menos 3 caracteres\")\n        \n        if not re.match(r'^[a-zA-Z0-9_-]+$', name):\n            raise ValueError(\"Nome da inst√¢ncia deve conter apenas letras, n√∫meros, _ e -\")\n        \n        return name\n    \n    @staticmethod\n    def validate_webhook_url(url: str) -> str:\n        \"\"\"Valida URL de webhook\"\"\"\n        url = InputSanitizer.sanitize_string(url, 500)\n        \n        # Valida formato de URL\n        if not re.match(r'^https?:\\/\\/[^\\s/$.?#].[^\\s]*$', url):\n            raise ValueError(\"URL de webhook inv√°lida\")\n        \n        # Bloqueia URLs locais em produ√ß√£o\n        if re.search(r'\\b(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0|10\\.|192\\.168\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.)\\b', url):\n            raise ValueError(\"URLs locais n√£o s√£o permitidas\")\n        \n        return url\n    \n    @staticmethod\n    def validate_message_content(content: str) -> str:\n        \"\"\"Valida conte√∫do de mensagem\"\"\"\n        content = InputSanitizer.sanitize_string(content, 4096)\n        \n        if len(content.strip()) == 0:\n            raise ValueError(\"Conte√∫do da mensagem n√£o pode estar vazio\")\n        \n        return content\n\n\nclass SecureEndpoint:\n    \"\"\"\n    Decorador para endpoints seguros\n    \"\"\"\n    \n    def __init__(\n        self,\n        access_level: AccessLevel = AccessLevel.AUTHENTICATED,\n        required_scopes: List[EndpointScope] = None,\n        rate_limit: Optional[int] = None,\n        validate_input: bool = True,\n        sanitize_input: bool = True,\n        audit_log: bool = True\n    ):\n        self.access_level = access_level\n        self.required_scopes = required_scopes or []\n        self.rate_limit = rate_limit\n        self.validate_input = validate_input\n        self.sanitize_input = sanitize_input\n        self.audit_log = audit_log\n    \n    def __call__(self, func: Callable) -> Callable:\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Extrai request dos argumentos\n            request = None\n            for arg in args:\n                if isinstance(arg, Request):\n                    request = arg\n                    break\n            \n            if not request:\n                # Procura nos kwargs\n                request = kwargs.get('request')\n            \n            if not request:\n                raise HTTPException(\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                    detail=\"Request object not found\"\n                )\n            \n            # Valida√ß√£o de acesso\n            user = await self._validate_access(request)\n            \n            # Sanitiza√ß√£o de input\n            if self.sanitize_input:\n                kwargs = await self._sanitize_inputs(kwargs)\n            \n            # Valida√ß√£o de input\n            if self.validate_input:\n                await self._validate_inputs(kwargs)\n            \n            # Auditoria\n            if self.audit_log:\n                await self._log_access(request, user, func.__name__)\n            \n            # Executa a fun√ß√£o\n            try:\n                result = await func(*args, **kwargs)\n                return result\n            except Exception as e:\n                await self._log_error(request, user, func.__name__, str(e))\n                raise\n        \n        return wrapper\n    \n    async def _validate_access(self, request: Request) -> Optional[User]:\n        \"\"\"Valida acesso ao endpoint\"\"\"\n        if self.access_level == AccessLevel.PUBLIC:\n            return None\n        \n        # Extrai token\n        auth_header = request.headers.get(\"authorization\")\n        if not auth_header or not auth_header.startswith(\"Bearer \"):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Token de acesso requerido\",\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n        \n        token = auth_header.split(\" \")[1]\n        \n        # Valida token (implementar integra√ß√£o com JWTAuthenticator)\n        # Por enquanto, simula√ß√£o\n        try:\n            # user = await jwt_authenticator.validate_token(token)\n            user = User(\n                id=\"user123\",\n                username=\"testuser\",\n                email=\"test@example.com\",\n                roles=[\"user\"],\n                scopes=self.required_scopes\n            )\n            \n            # Valida n√≠vel de acesso\n            if self.access_level == AccessLevel.ADMIN and \"admin\" not in user.roles:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=\"Acesso de administrador requerido\"\n                )\n            \n            # Valida escopos\n            if self.required_scopes:\n                user_scopes = set(user.scopes)\n                required_scopes = set(scope.value for scope in self.required_scopes)\n                if not required_scopes.issubset(user_scopes):\n                    raise HTTPException(\n                        status_code=status.HTTP_403_FORBIDDEN,\n                        detail=f\"Escopos requeridos: {', '.join(required_scopes)}\"\n                    )\n            \n            return user\n            \n        except AuthenticationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=str(e),\n                headers={\"WWW-Authenticate\": \"Bearer\"}\n            )\n    \n    async def _sanitize_inputs(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Sanitiza inputs\"\"\"\n        sanitized = {}\n        \n        for key, value in kwargs.items():\n            if isinstance(value, str):\n                sanitized[key] = InputSanitizer.sanitize_string(value)\n            elif isinstance(value, dict):\n                sanitized[key] = InputSanitizer.sanitize_json(value)\n            elif hasattr(value, '__dict__'):\n                # Pydantic model\n                try:\n                    data = value.dict()\n                    sanitized_data = InputSanitizer.sanitize_json(data)\n                    sanitized[key] = type(value)(**sanitized_data)\n                except Exception:\n                    sanitized[key] = value\n            else:\n                sanitized[key] = value\n        \n        return sanitized\n    \n    async def _validate_inputs(self, kwargs: Dict[str, Any]):\n        \"\"\"Valida inputs espec√≠ficos\"\"\"\n        # Implementar valida√ß√µes espec√≠ficas baseadas no tipo de endpoint\n        pass\n    \n    async def _log_access(self, request: Request, user: Optional[User], endpoint: str):\n        \"\"\"Registra acesso ao endpoint\"\"\"\n        client_ip = request.headers.get(\"x-forwarded-for\", request.client.host if request.client else \"unknown\")\n        \n        logger.info(\n            f\"üîê Acesso ao endpoint: {endpoint} | \"\n            f\"IP: {client_ip} | \"\n            f\"Usu√°rio: {user.username if user else 'an√¥nimo'} | \"\n            f\"M√©todo: {request.method} | \"\n            f\"Path: {request.url.path}\",\n            extra={\n                \"endpoint_access\": {\n                    \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                    \"endpoint\": endpoint,\n                    \"client_ip\": client_ip,\n                    \"user_id\": user.id if user else None,\n                    \"username\": user.username if user else None,\n                    \"method\": request.method,\n                    \"path\": str(request.url.path),\n                    \"user_agent\": request.headers.get(\"user-agent\", \"\")\n                }\n            }\n        )\n    \n    async def _log_error(self, request: Request, user: Optional[User], endpoint: str, error: str):\n        \"\"\"Registra erro no endpoint\"\"\"\n        client_ip = request.headers.get(\"x-forwarded-for\", request.client.host if request.client else \"unknown\")\n        \n        logger.error(\n            f\"‚ùå Erro no endpoint: {endpoint} | \"\n            f\"IP: {client_ip} | \"\n            f\"Usu√°rio: {user.username if user else 'an√¥nimo'} | \"\n            f\"Erro: {error}\",\n            extra={\n                \"endpoint_error\": {\n                    \"timestamp\": datetime.now(timezone.utc).isoformat(),\n                    \"endpoint\": endpoint,\n                    \"client_ip\": client_ip,\n                    \"user_id\": user.id if user else None,\n                    \"username\": user.username if user else None,\n                    \"error\": error,\n                    \"method\": request.method,\n                    \"path\": str(request.url.path)\n                }\n            }\n        )\n\n\n# Schemas seguros para valida√ß√£o\nclass SecureAgentCreate(BaseModel):\n    \"\"\"Schema seguro para cria√ß√£o de agente\"\"\"\n    name: str\n    description: str\n    specialization: str\n    model: str = \"claude-3-5-sonnet-20241022\"\n    temperature: float = 0.7\n    max_tokens: int = 4000\n    \n    @validator('name')\n    def validate_name(cls, v):\n        return SecureValidator.validate_agent_name(v)\n    \n    @validator('description')\n    def validate_description(cls, v):\n        return InputSanitizer.sanitize_string(v, 500)\n    \n    @validator('specialization')\n    def validate_specialization(cls, v):\n        allowed = ['CUSTOMER_SERVICE', 'SALES', 'SUPPORT', 'MARKETING', 'GENERAL']\n        if v.upper() not in allowed:\n            raise ValueError(f\"Especializa√ß√£o deve ser uma de: {', '.join(allowed)}\")\n        return v.upper()\n    \n    @validator('temperature')\n    def validate_temperature(cls, v):\n        if not 0.0 <= v <= 2.0:\n            raise ValueError(\"Temperature deve estar entre 0.0 e 2.0\")\n        return v\n    \n    @validator('max_tokens')\n    def validate_max_tokens(cls, v):\n        if not 100 <= v <= 8000:\n            raise ValueError(\"Max tokens deve estar entre 100 e 8000\")\n        return v\n\n\nclass SecureInstanceCreate(BaseModel):\n    \"\"\"Schema seguro para cria√ß√£o de inst√¢ncia\"\"\"\n    instanceName: str\n    token: str\n    qrcode: bool = True\n    webhook: Optional[str] = None\n    webhook_by_events: bool = False\n    \n    @validator('instanceName')\n    def validate_instance_name(cls, v):\n        return SecureValidator.validate_instance_name(v)\n    \n    @validator('token')\n    def validate_token(cls, v):\n        token = InputSanitizer.sanitize_string(v, 200)\n        if len(token) < 10:\n            raise ValueError(\"Token deve ter pelo menos 10 caracteres\")\n        return token\n    \n    @validator('webhook')\n    def validate_webhook(cls, v):\n        if v:\n            return SecureValidator.validate_webhook_url(v)\n        return v\n\n\nclass SecureSendMessage(BaseModel):\n    \"\"\"Schema seguro para envio de mensagem\"\"\"\n    number: str\n    text: str\n    \n    @validator('number')\n    def validate_number(cls, v):\n        return InputSanitizer.sanitize_phone(v)\n    \n    @validator('text')\n    def validate_text(cls, v):\n        return SecureValidator.validate_message_content(v)\n\n\n# Fun√ß√µes auxiliares para endpoints\ndef require_auth(\n    access_level: AccessLevel = AccessLevel.AUTHENTICATED,\n    scopes: List[EndpointScope] = None\n):\n    \"\"\"Decorador simples para autentica√ß√£o\"\"\"\n    return SecureEndpoint(\n        access_level=access_level,\n        required_scopes=scopes or []\n    )\n\n\ndef require_admin():\n    \"\"\"Decorador para endpoints de admin\"\"\"\n    return SecureEndpoint(\n        access_level=AccessLevel.ADMIN,\n        required_scopes=[EndpointScope.ADMIN]\n    )\n\n\ndef public_endpoint():\n    \"\"\"Decorador para endpoints p√∫blicos\"\"\"\n    return SecureEndpoint(\n        access_level=AccessLevel.PUBLIC,\n        audit_log=False\n    )\n\n\ndef webhook_endpoint():\n    \"\"\"Decorador para endpoints de webhook\"\"\"\n    return SecureEndpoint(\n        access_level=AccessLevel.PUBLIC,\n        required_scopes=[EndpointScope.WEBHOOK],\n        rate_limit=1000,  # Alto limite para webhooks\n        audit_log=True\n    )\n"}},"query_language":"Portuguese"}}